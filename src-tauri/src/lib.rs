mod db;

use base64::Engine;
use chrono::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::io::{BufRead, BufReader, Read};
use std::path::{Path, PathBuf};
use std::process::{Child, Command, Stdio};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH};
use tauri::path::BaseDirectory;
use tauri::{AppHandle, Emitter, Manager, State};
use url::Url;

#[cfg(unix)]
use std::os::unix::process::CommandExt;

struct RunEntry {
    child: Child,
    label: String,
}

struct RunningState {
    runs: Arc<Mutex<HashMap<String, RunEntry>>>,
}

impl Default for RunningState {
    fn default() -> Self {
        Self {
            runs: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunIdResponse {
    pub run_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScriptLogPayload {
    pub run_id: String,
    pub line: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScriptExitedPayload {
    pub run_id: String,
    pub label: String,
    /// Exit code of the script process when available (e.g. 0 = success, non-zero = failure).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exit_code: Option<i32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunningRunInfo {
    pub run_id: String,
    pub label: String,
}

// #region agent log
fn debug_log(location: &str, message: &str, data: &[(&str, &str)]) {
    let data_obj: std::collections::HashMap<String, String> = data.iter().map(|(k, v)| ((*k).to_string(), (*v).to_string())).collect();
    let payload = serde_json::json!({
        "timestamp": SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis(),
        "location": location,
        "message": message,
        "data": data_obj,
        "hypothesisId": "A"
    });
    if let Ok(line) = serde_json::to_string(&payload) {
        let _ = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open("/Users/nenadkalicanin/Documents/February/KW-February-KWCode/.cursor/debug.log")
            .and_then(|mut f| std::io::Write::write_all(&mut f, format!("{}\n", line).as_bytes()));
    }
}
// #endregion

fn gen_run_id() -> String {
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_nanos();
    format!("run-{}", nanos)
}

// Helper to generate current ISO 8601 timestamp
fn now_iso() -> String {
    Utc::now().to_rfc3339_opts(SecondsFormat::Millis, true)
}

fn get_seed_prompts() -> Vec<Prompt> {
    let now = now_iso();
    vec![
        Prompt {
            id: "prompt-1".to_string(),
            title: "Initial Project Setup".to_string(),
            content: "Generate a basic project structure for a Next.js application with Tailwind CSS and TypeScript.".to_string(),
            created_at: now.clone(),
            updated_at: now.clone(),
        },
        Prompt {
            id: "prompt-2".to_string(),
            title: "Create User Authentication Flow".to_string(),
            content: "Implement a complete user authentication flow including signup, login, and password reset functionalities.".to_string(),
            created_at: now.clone(),
            updated_at: now.clone(),
        },
    ]
}

fn get_seed_designs() -> Vec<Design> {
    let now = now_iso();
    vec![
        Design {
            id: "design-1".to_string(),
            name: "Dashboard Layout".to_string(),
            description: Some("Responsive dashboard layout with a sidebar navigation and a main content area.".to_string()),
            image_url: Some("https://example.com/dashboard-layout.png".to_string()),
            created_at: now.clone(),
            updated_at: now.clone(),
        },
        Design {
            id: "design-2".to_string(),
            name: "User Profile Page".to_string(),
            description: Some("Clean and modern user profile page displaying user information, settings, and activity feed.".to_string()),
            image_url: Some("https://example.com/user-profile.png".to_string()),
            created_at: now.clone(),
            updated_at: now.clone(),
        },
    ]
}

fn seed_initial_data(conn: &rusqlite::Connection) -> Result<(), String> {
    // Seed Prompts
    let prompts_count: i64 = conn.query_row(
        "SELECT COUNT(*) FROM prompts",
        [],
        |row| row.get(0),
    ).map_err(|e| e.to_string())?;

    if prompts_count == 0 {
        println!("Seeding initial prompts...");
        db::save_prompts(conn, &get_seed_prompts())?;
    }

    // Seed Designs
    let designs_count: i64 = conn.query_row(
        "SELECT COUNT(*) FROM designs",
        [],
        |row| row.get(0),
    ).map_err(|e| e.to_string())?;

    if designs_count == 0 {
        println!("Seeding initial designs...");
        db::save_designs(conn, &get_seed_designs())?;
    }

    Ok(())
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ticket {
    pub id: String,
    pub title: String,
    pub description: String,
    pub status: String, // "backlog" | "in_progress" | "done" | "blocked"
    #[serde(default)]
    pub priority: i32,
    pub created_at: String,
    pub updated_at: String,
    // Legacy: read for migration, never serialized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prompt_ids: Option<Vec<u32>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project_paths: Option<Vec<String>>,
}

/// A milestone that has to be done in an application. One feature has many tickets and must have at least one.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Feature {
    pub id: String,
    pub title: String, // label for run / display
    /// At least one ticket; a feature groups work items (tickets) for this milestone.
    #[serde(default)]
    pub ticket_ids: Vec<String>,
    #[serde(default)]
    pub prompt_ids: Vec<u32>,
    #[serde(default)]
    pub project_paths: Vec<String>, // empty = use active projects
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Prompt {
    pub id: String,
    pub title: String,
    pub content: String,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Design {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub image_url: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RunScriptArgs {
    #[serde(default)]
    pub prompt_ids: Vec<u32>,
    #[serde(default)]
    pub combined_prompt: Option<String>,
    #[serde(default)]
    pub active_projects: Vec<String>,
    pub timing: TimingParams,
    pub run_label: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimingParams {
    pub sleep_after_open_project: f64,
    pub sleep_after_window_focus: f64,
    pub sleep_between_shift_tabs: f64,
    pub sleep_after_all_shift_tabs: f64,
    pub sleep_after_cmd_n: f64,
    pub sleep_before_paste: f64,
    pub sleep_after_paste: f64,
    pub sleep_after_enter: f64,
    pub sleep_between_projects: f64,
    pub sleep_between_rounds: f64,
}

/// Git repository info for the project details Git tab.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct GitInfo {
    pub current_branch: String,
    pub branches: Vec<String>,
    pub remotes: String,
    pub status_short: String,
    pub last_commits: Vec<String>,
    pub head_ref: String,
    pub config_preview: String,
}

fn run_git(project_path: &PathBuf, args: &[&str]) -> Result<String, String> {
    let out = Command::new("git")
        .args(args)
        .current_dir(project_path)
        .output()
        .map_err(|e| e.to_string())?;
    let stdout = String::from_utf8_lossy(&out.stdout).trim().to_string();
    let stderr = String::from_utf8_lossy(&out.stderr).trim().to_string();
    if out.status.success() {
        Ok(stdout)
    } else {
        Err(if stderr.is_empty() { stdout } else { stderr })
    }
}

#[tauri::command]
fn get_git_info(project_path: String) -> Result<GitInfo, String> {
    let path_buf = PathBuf::from(project_path.trim());
    if path_buf.as_os_str().is_empty() {
        return Err("Project path is empty".to_string());
    }
    if !path_buf.exists() || !path_buf.is_dir() {
        return Err("Project path does not exist or is not a directory".to_string());
    }
    let git_dir = path_buf.join(".git");
    if !git_dir.exists() {
        return Err("Not a git repository (no .git)".to_string());
    }

    let mut info = GitInfo::default();

    // HEAD ref (e.g. ref: refs/heads/main)
    let head_path = git_dir.join("HEAD");
    if head_path.is_file() {
        info.head_ref = std::fs::read_to_string(&head_path).unwrap_or_default().trim().to_string();
        if info.head_ref.starts_with("ref: ") {
            info.current_branch = info.head_ref.trim_start_matches("ref: refs/heads/").to_string();
        }
    }

    // git status -sb
    if let Ok(s) = run_git(&path_buf, &["status", "-sb"]) {
        info.status_short = s;
    }

    // git branch -a
    if let Ok(s) = run_git(&path_buf, &["branch", "-a"]) {
        info.branches = s.lines().map(|l| l.trim().to_string()).filter(|l| !l.is_empty()).collect();
    }

    // git remote -v
    if let Ok(s) = run_git(&path_buf, &["remote", "-v"]) {
        info.remotes = s;
    }

    // git log -n 30 --oneline
    if let Ok(s) = run_git(&path_buf, &["log", "-n", "30", "--oneline"]) {
        info.last_commits = s.lines().map(|l| l.to_string()).filter(|l| !l.is_empty()).collect();
    }

    // .git/config preview (first 4KB, sanitized)
    let config_path = git_dir.join("config");
    if config_path.is_file() {
        if let Ok(content) = std::fs::read_to_string(&config_path) {
            let max_len = 4096;
            info.config_preview = if content.len() > max_len {
                format!("{}...", &content[..max_len])
            } else {
                content
            };
        }
    }

    Ok(info)
}

#[tauri::command]
fn get_git_head(project_path: String) -> Result<String, String> {
    let path_buf = PathBuf::from(project_path.trim());
    if path_buf.as_os_str().is_empty() || !path_buf.exists() || !path_buf.is_dir() {
        return Ok(String::new());
    }
    let git_dir = path_buf.join(".git");
    if !git_dir.exists() {
        return Ok(String::new());
    }
    Ok(run_git(&path_buf, &["rev-parse", "HEAD"]).unwrap_or_default())
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GitDiffNameStatusEntry {
    pub path: String,
    pub status: String,
}

#[tauri::command]
fn get_git_diff_name_status(project_path: String, from_ref: String) -> Result<Vec<GitDiffNameStatusEntry>, String> {
    let path_buf = PathBuf::from(project_path.trim());
    if !path_buf.exists() || !path_buf.is_dir() {
        return Err("Project path does not exist".to_string());
    }
    if !path_buf.join(".git").exists() {
        return Ok(Vec::new());
    }
    let ref_arg = if from_ref.trim().is_empty() { "HEAD" } else { from_ref.trim() };
    let out = run_git(&path_buf, &["diff", "--name-status", ref_arg, "--", "."]);
    let stdout = match out {
        Ok(s) => s,
        Err(_) => return Ok(Vec::new()),
    };
    let mut entries = Vec::new();
    for line in stdout.lines() {
        let line = line.trim();
        if line.is_empty() {
            continue;
        }
        let mut it = line.splitn(2, '\t');
        let status = it.next().unwrap_or("").to_string();
        let path = it.next().unwrap_or("").to_string();
        if !path.is_empty() {
            entries.push(GitDiffNameStatusEntry { path, status });
        }
    }
    Ok(entries)
}

#[derive(serde::Serialize)]
pub struct ImplementationLogEntry {
    pub id: i64,
    pub project_id: String,
    pub run_id: String,
    pub ticket_number: i64,
    pub ticket_title: String,
    pub milestone_id: Option<i64>,
    pub idea_id: Option<i64>,
    pub completed_at: String,
    pub files_changed: String,
    pub summary: String,
    pub created_at: String,
    pub status: String,
}

#[tauri::command]
fn get_implementation_log_entries(ProjectIdArg { project_id }: ProjectIdArg) -> Result<Vec<ImplementationLogEntry>, String> {
    with_db(|conn| {
        let mut stmt = conn.prepare(
            "SELECT id, project_id, run_id, ticket_number, ticket_title, milestone_id, idea_id, completed_at, files_changed, summary, created_at, status FROM implementation_log WHERE project_id = ?1 ORDER BY completed_at DESC, id DESC",
        )
        .map_err(|e| e.to_string())?;
        let rows = stmt
            .query_map(rusqlite::params![project_id.trim()], |row| {
                Ok(ImplementationLogEntry {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    run_id: row.get(2)?,
                    ticket_number: row.get(3)?,
                    ticket_title: row.get(4)?,
                    milestone_id: row.get(5)?,
                    idea_id: row.get(6)?,
                    completed_at: row.get(7)?,
                    files_changed: row.get(8)?,
                    summary: row.get(9)?,
                    created_at: row.get(10)?,
                    status: row.get::<_, String>(11).unwrap_or_else(|_| "pending".to_string()),
                })
            })
            .map_err(|e| e.to_string())?;
        let entries: Vec<ImplementationLogEntry> = rows
            .filter_map(|r| r.ok())
            .collect();
        Ok(entries)
    })
}

/// Args for project-scoped commands; accept camelCase projectId from frontend.
#[derive(serde::Deserialize)]
struct ProjectIdArg {
    #[serde(alias = "projectId")]
    project_id: String,
}

#[derive(serde::Deserialize)]
struct ProjectIdArgOptional {
    #[serde(alias = "projectId", default)]
    project_id: Option<String>,
}

/// Project-scoped tickets (plan_tickets). Used when isTauri to avoid fetch to /api which triggers URL parse error.
#[tauri::command]
fn get_project_tickets(ProjectIdArg { project_id }: ProjectIdArg) -> Result<Vec<serde_json::Value>, String> {
    with_db(|conn| db::get_plan_tickets_for_project(conn, &project_id))
}

/// Project kanban state (inProgressIds). Used when isTauri to avoid fetch to /api.
#[tauri::command]
fn get_project_kanban_state(ProjectIdArg { project_id }: ProjectIdArg) -> Result<serde_json::Value, String> {
    with_db(|conn| db::get_plan_kanban_state_for_project(conn, &project_id))
}

/// Project milestones. Used when isTauri to avoid fetch to /api.
#[tauri::command]
fn get_project_milestones(ProjectIdArg { project_id }: ProjectIdArg) -> Result<Vec<serde_json::Value>, String> {
    with_db(|conn| db::get_milestones_for_project(conn, &project_id))
}

/// Create a plan ticket (for Fast development in Tauri mode; avoids fetch to /api).
#[tauri::command]
fn create_plan_ticket(
    project_id: String,
    title: String,
    description: Option<String>,
    priority: Option<String>,
    feature_name: Option<String>,
    milestone_id: i64,
    idea_id: Option<i64>,
    agents: Option<String>,
) -> Result<serde_json::Value, String> {
    with_db(|conn| {
        db::create_plan_ticket(
            conn,
            &project_id,
            &title,
            description.as_deref(),
            priority.as_deref().unwrap_or("P1"),
            feature_name.as_deref().unwrap_or("General"),
            milestone_id,
            idea_id,
            agents.as_deref(),
        )
    })
}

/// Set plan kanban in-progress IDs (for Fast development in Tauri mode; avoids fetch to /api).
#[tauri::command]
fn set_plan_kanban_state(project_id: String, in_progress_ids: Vec<String>) -> Result<(), String> {
    with_db(|conn| db::set_plan_kanban_state_for_project(conn, &project_id, &in_progress_ids))
}

/// Update a plan ticket's done and status (for Worker tab Mark done/Redo; avoids fetch in Tauri).
#[tauri::command]
fn update_plan_ticket(
    project_id: String,
    ticket_id: String,
    done: bool,
    status: String,
) -> Result<(), String> {
    with_db(|conn| db::update_plan_ticket(conn, &project_id, &ticket_id, done, status.trim()))
}

/// Delete a plan ticket (for Worker tab Archive; avoids fetch in Tauri).
#[tauri::command]
fn delete_plan_ticket(project_id: String, ticket_id: String) -> Result<(), String> {
    with_db(|conn| db::delete_plan_ticket(conn, &project_id, &ticket_id))
}

/// Ideas list (optional project filter). Used when isTauri to avoid fetch to /api.
#[tauri::command]
fn get_ideas_list(ProjectIdArgOptional { project_id }: ProjectIdArgOptional) -> Result<Vec<serde_json::Value>, String> {
    with_db(|conn| db::get_ideas_list(conn, project_id.as_deref()))
}

#[tauri::command]
fn update_implementation_log_entry_status(
    project_id: String,
    entry_id: i64,
    status: String,
) -> Result<ImplementationLogEntry, String> {
    let status = status.trim();
    if status != "accepted" && status != "declined" {
        return Err("status must be 'accepted' or 'declined'".to_string());
    }
    with_db(|conn| {
        let updated = conn
            .execute(
                "UPDATE implementation_log SET status = ?1 WHERE id = ?2 AND project_id = ?3",
                rusqlite::params![status, entry_id, project_id.trim()],
            )
            .map_err(|e| e.to_string())?;
        if updated == 0 {
            return Err("Implementation log entry not found".to_string());
        }
        let entry = conn.query_row(
            "SELECT id, project_id, run_id, ticket_number, ticket_title, milestone_id, idea_id, completed_at, files_changed, summary, created_at, status FROM implementation_log WHERE id = ?1",
            rusqlite::params![entry_id],
            |row| {
                Ok(ImplementationLogEntry {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    run_id: row.get(2)?,
                    ticket_number: row.get(3)?,
                    ticket_title: row.get(4)?,
                    milestone_id: row.get(5)?,
                    idea_id: row.get(6)?,
                    completed_at: row.get(7)?,
                    files_changed: row.get(8)?,
                    summary: row.get(9)?,
                    created_at: row.get(10)?,
                    status: row.get::<_, String>(11).unwrap_or_else(|_| "pending".to_string()),
                })
            },
        )
        .map_err(|e| e.to_string())?;
        Ok(entry)
    })
}

#[tauri::command]
fn append_implementation_log_entry(
    project_id: String,
    run_id: String,
    ticket_number: i64,
    ticket_title: String,
    milestone_id: Option<i64>,
    idea_id: Option<i64>,
    completed_at: String,
    files_changed: String,
    summary: String,
) -> Result<(), String> {
    with_db(|conn| {
        conn.execute(
            "INSERT INTO implementation_log (project_id, run_id, ticket_number, ticket_title, milestone_id, idea_id, completed_at, files_changed, summary, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)",
            rusqlite::params![
                project_id.trim(),
                run_id.trim(),
                ticket_number,
                ticket_title.trim(),
                milestone_id,
                idea_id,
                completed_at.trim(),
                if files_changed.trim().is_empty() { "[]" } else { files_changed.trim() },
                summary.trim(),
                now_iso(),
            ],
        )
        .map_err(|e| e.to_string())?;
        Ok(())
    })
}

/// Return git diff and full file content for a changed file. Used when clicking a file in the Git tab.
#[derive(serde::Serialize)]
pub struct GitFileView {
    pub diff: String,
    pub full_content: Option<String>,
}

#[tauri::command]
fn get_git_file_view(project_path: String, file_path: String) -> Result<GitFileView, String> {
    let path_buf = PathBuf::from(project_path.trim());
    if !path_buf.exists() || !path_buf.is_dir() {
        return Err("Project path does not exist".to_string());
    }
    let git_dir = path_buf.join(".git");
    if !git_dir.exists() {
        return Err("Not a git repository".to_string());
    }
    let file_path = file_path.trim();
    if file_path.is_empty() {
        return Err("File path is empty".to_string());
    }
    let full_path = path_buf.join(file_path);
    let exists = full_path.exists() && full_path.is_file();

    let mut diff_parts = vec![];
    if let Ok(staged) = run_git(&path_buf, &["diff", "--staged", "--", file_path]) {
        if !staged.is_empty() {
            diff_parts.push(format!("=== Staged changes ===\n{}\n", staged));
        }
    }
    if let Ok(unstaged) = run_git(&path_buf, &["diff", "--", file_path]) {
        if !unstaged.is_empty() {
            diff_parts.push(format!("=== Unstaged changes ===\n{}\n", unstaged));
        }
    }
    let diff = if diff_parts.is_empty() && exists {
        "(no changes or untracked file)".to_string()
    } else {
        diff_parts.join("\n")
    };

    let full_content = if exists {
        std::fs::read_to_string(&full_path).ok()
    } else {
        None
    };

    Ok(GitFileView { diff, full_content })
}

fn validate_git_repo(project_path: &str) -> Result<PathBuf, String> {
    let path_buf = PathBuf::from(project_path.trim());
    if path_buf.as_os_str().is_empty() {
        return Err("Project path is empty".to_string());
    }
    if !path_buf.exists() || !path_buf.is_dir() {
        return Err("Project path does not exist or is not a directory".to_string());
    }
    if !path_buf.join(".git").exists() {
        return Err("Not a git repository (no .git)".to_string());
    }
    Ok(path_buf)
}

#[tauri::command]
fn git_fetch(project_path: String) -> Result<String, String> {
    let path_buf = validate_git_repo(&project_path)?;
    run_git(&path_buf, &["fetch"])
}

#[tauri::command]
fn git_pull(project_path: String) -> Result<String, String> {
    let path_buf = validate_git_repo(&project_path)?;
    run_git(&path_buf, &["pull"])
}

#[tauri::command]
fn git_push(project_path: String) -> Result<String, String> {
    let path_buf = validate_git_repo(&project_path)?;
    run_git(&path_buf, &["push"])
}

#[tauri::command]
fn git_commit(project_path: String, message: String) -> Result<String, String> {
    let path_buf = validate_git_repo(&project_path)?;
    let msg = message.trim();
    if msg.is_empty() {
        return Err("Commit message cannot be empty".to_string());
    }
    run_git(&path_buf, &["add", "-A"])?;
    run_git(&path_buf, &["commit", "-m", msg])
}

fn is_valid_workspace(p: &PathBuf) -> bool {
    let has_implement_all = p.join("script").join("implement_all.sh").exists()
        || p.join("script").join("worker").join("implement_all.sh").exists();
    has_implement_all && p.join("data").is_dir()
}

fn data_dir(ws: &PathBuf) -> PathBuf {
    let data = ws.join("data");
    if data.is_dir() {
        data
    } else {
        ws.clone()
    }
}

fn script_path(ws: &PathBuf) -> PathBuf {
    ws.join("script").join("run_prompts_all_projects.sh")
}

fn analysis_script_path(ws: &PathBuf) -> PathBuf {
    ws.join("script").join("run_analysis_single_project.sh")
}

fn implement_all_script_path(ws: &PathBuf) -> PathBuf {
    ws.join("script").join("worker").join("implement_all.sh")
}

fn run_terminal_agent_script_path(ws: &PathBuf) -> PathBuf {
    ws.join("script").join("worker").join("run_terminal_agent.sh")
}

/// Resolve project root (contains script/ and data/). Tries current working directory first,
/// then walks up from the executable path so the app finds data when launched from any cwd.
fn project_root() -> Result<PathBuf, String> {
    // 1) Try current working directory (e.g. when running `tauri dev` from repo root)
    let mut candidate = std::env::current_dir().map_err(|e| e.to_string())?;
    if candidate.join("src-tauri").exists() {
        candidate = candidate.parent().unwrap_or(&candidate).to_path_buf();
    }
    if is_valid_workspace(&candidate) {
        return Ok(candidate);
    }

    // 2) Walk up from executable path (e.g. built app or dev binary in target/debug)
    if let Ok(exe) = std::env::current_exe() {
        let mut dir = exe.parent().map(PathBuf::from).unwrap_or_default();
        for _ in 0..20 {
            if dir.as_os_str().is_empty() {
                break;
            }
            if is_valid_workspace(&dir) {
                return Ok(dir);
            }
            if let Some(p) = dir.parent() {
                dir = p.to_path_buf();
            } else {
                break;
            }
        }
    }

    // #region agent log
    let err_msg = "Project root not found. Run the app from the repo root (contains script/worker/implement_all.sh and data/).";
    debug_log("lib.rs:project_root", "project_root returning Err", &[("err", err_msg)]);
    // #endregion
    Err(err_msg.to_string())
}

/// App data directory for the built app (e.g. ~/Library/Application Support/com.kwcode.app/data). Created if missing.
fn app_data_data_dir() -> Result<PathBuf, String> {
    let home = std::env::var("HOME").map_err(|_| "HOME not set".to_string())?;
    #[cfg(target_os = "macos")]
    let app_data = PathBuf::from(&home).join("Library").join("Application Support").join("com.kwcode.app");
    #[cfg(not(target_os = "macos"))]
    let app_data = PathBuf::from(&home).join(".local").join("share").join("com.kwcode.app");
    let data = app_data.join("data");
    std::fs::create_dir_all(&data).map_err(|e| e.to_string())?;
    Ok(data)
}

/// Frontend can call this to append a debug log line (e.g. when running from Desktop so ingest server may be unreachable).
#[tauri::command]
fn frontend_debug_log(location: String, message: String, data: Option<serde_json::Value>) {
    let data = data.unwrap_or(serde_json::json!({}));
    let payload = serde_json::json!({
        "timestamp": SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis(),
        "location": location,
        "message": message,
        "data": data,
        "source": "frontend"
    });
    if let Ok(line) = serde_json::to_string(&payload) {
        if let Ok(dir) = app_data_data_dir() {
            let path = dir.join("debug.log");
            let _ = std::fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(&path)
                .and_then(|mut f| std::io::Write::write_all(&mut f, format!("{}\n", line).as_bytes()));
        }
    }
}

/// Returns the app version (from Cargo.toml package version) for display in Configuration and support.
#[tauri::command]
fn get_app_version(app: AppHandle) -> Result<String, String> {
    Ok(app.package_info().version.to_string())
}

/// Navigate the webview by setting window.location.href via eval. We never parse the URL in Rust nor call w.navigate(),
/// so the user never sees "The string did not match the expected pattern" (url crate / WebView).
#[tauri::command]
fn navigate_webview_to(app: AppHandle, url: String) -> Result<(), String> {
    let escaped = serde_json::to_string(&url).unwrap_or_else(|_| "\"/\"".to_string());
    let app_clone = app.clone();
    let _ = app.run_on_main_thread(move || {
        if let Some((_, w)) = app_clone.webview_windows().into_iter().next() {
            let _ = w.eval(&format!("window.location.href = {};", escaped));
        }
    });
    Ok(())
}

/// Directory that holds app.db and february-dir.txt. In dev: repo data dir; when bundled: app data dir so DB and config work.
fn data_root() -> Result<PathBuf, String> {
    // #region agent log
    debug_log("lib.rs:data_root", "data_root called", &[]);
    // #endregion
    if let Ok(ws) = project_root() {
        // #region agent log
        debug_log("lib.rs:data_root", "data_root: using project_root", &[("path", ws.to_string_lossy().as_ref())]);
        // #endregion
        return Ok(data_dir(&ws));
    }
    // #region agent log
    debug_log("lib.rs:data_root", "data_root: project_root failed, using app_data_data_dir", &[]);
    // #endregion
    app_data_data_dir()
}

/// Read a file from disk and return its contents as base64 (for sending to API for PDF/text extraction).
#[tauri::command]
fn read_file_as_base64(path: String) -> Result<String, String> {
    let path_buf = PathBuf::from(path.trim());
    if !path_buf.exists() {
        return Err("File does not exist".to_string());
    }
    if !path_buf.is_file() {
        return Err("Path is not a file".to_string());
    }
    let bytes = std::fs::read(&path_buf).map_err(|e| e.to_string())?;
    Ok(base64::engine::general_purpose::STANDARD.encode(&bytes))
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEntry {
    pub name: String,
    pub path: String,
}

/// Read a text file under project root (script/ or data/). Path must be relative to project root or absolute under it.
#[tauri::command]
fn read_file_text(path: String) -> Result<String, String> {
    let ws = project_root()?;
    let path_buf = PathBuf::from(path.trim());
    let canonical = if path_buf.is_absolute() {
        path_buf.canonicalize().map_err(|e| e.to_string())?
    } else {
        ws.join(path_buf).canonicalize().map_err(|e| e.to_string())?
    };
    if !canonical.starts_with(ws.canonicalize().map_err(|e| e.to_string())?) {
        return Err("Path must be under project root".to_string());
    }
    if !canonical.is_file() {
        return Err("Path is not a file".to_string());
    }
    let content = std::fs::read_to_string(&canonical).map_err(|e| e.to_string())?;
    Ok(content)
}

/// Read a text file under a given root (e.g. project repo path). Use for project spec files from .cursor in another repo.
#[tauri::command]
fn read_file_text_under_root(root: String, path: String) -> Result<String, String> {
    let root_buf = PathBuf::from(root.trim());
    let root_canonical = root_buf.canonicalize().map_err(|e| e.to_string())?;
    let path_buf = PathBuf::from(path.trim());
    let canonical = if path_buf.is_absolute() {
        path_buf.canonicalize().map_err(|e| e.to_string())?
    } else {
        root_canonical.join(path_buf).canonicalize().map_err(|e| e.to_string())?
    };
    if !canonical.starts_with(&root_canonical) {
        return Err("Path must be under project root".to_string());
    }
    if !canonical.is_file() {
        return Err("Path is not a file".to_string());
    }
    let content = std::fs::read_to_string(&canonical).map_err(|e| e.to_string())?;
    Ok(content)
}

/// Entry for one directory listing (one level under a root). Matches frontend FileEntry shape.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirListingEntry {
    pub name: String,
    #[serde(rename = "isDirectory")]
    pub is_directory: bool,
    pub size: u64,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
}

/// List one level of files/dirs under a given root (e.g. project repo path). Used by Project Files in Stakeholder tab.
#[tauri::command]
fn list_files_under_root(root: String, path: String) -> Result<Vec<DirListingEntry>, String> {
    let root_buf = PathBuf::from(root.trim());
    let root_canonical = root_buf.canonicalize().map_err(|e| e.to_string())?;
    let path_buf = PathBuf::from(path.trim().trim_start_matches('/'));
    let full = if path_buf.as_os_str().is_empty() || path_buf == Path::new(".") {
        root_canonical.clone()
    } else {
        root_canonical.join(path_buf)
    };
    if !full.exists() {
        return Ok(vec![]);
    }
    let dir = full.canonicalize().map_err(|e| e.to_string())?;
    if !dir.starts_with(&root_canonical) {
        return Err("Path must be under project root".to_string());
    }
    if !dir.is_dir() {
        return Err("Path is not a directory".to_string());
    }
    let mut entries = Vec::new();
    for e in std::fs::read_dir(&dir).map_err(|e| e.to_string())? {
        let e = e.map_err(|e| e.to_string())?;
        let path = e.path();
        let name = path.file_name().and_then(|n| n.to_str()).unwrap_or("").to_string();
        if name.is_empty() || name == "." || name == ".." {
            continue;
        }
        let meta = std::fs::metadata(&path).map_err(|e| e.to_string())?;
        let is_directory = path.is_dir();
        let size = if is_directory { 0 } else { meta.len() };
        let updated_at = meta
            .modified()
            .ok()
            .map(|t| {
                let dt: DateTime<Utc> = t.into();
                dt.format("%Y-%m-%dT%H:%M:%SZ").to_string()
            })
            .unwrap_or_default();
        entries.push(DirListingEntry {
            name,
            is_directory,
            size,
            updated_at,
        });
    }
    entries.sort_by(|a, b| {
        if a.is_directory != b.is_directory {
            return a.is_directory.cmp(&b.is_directory).reverse();
        }
        a.name.to_lowercase().cmp(&b.name.to_lowercase())
    });
    Ok(entries)
}

/// List files in script/ directory.
#[tauri::command]
fn list_scripts() -> Result<Vec<FileEntry>, String> {
    let ws = project_root()?;
    let script_dir = ws.join("script");
    if !script_dir.is_dir() {
        return Ok(vec![]);
    }
    let mut entries = vec![];
    for e in std::fs::read_dir(&script_dir).map_err(|e| e.to_string())? {
        let e = e.map_err(|e| e.to_string())?;
        let path = e.path();
        if path.is_file() {
            let name = path.file_name().and_then(|n| n.to_str()).unwrap_or("").to_string();
            let path_str = path.to_string_lossy().to_string();
            entries.push(FileEntry { name, path: path_str });
        }
    }
    entries.sort_by(|a, b| a.name.cmp(&b.name));
    Ok(entries)
}

/// List all files under project_path/.cursor (recursive). Returns empty vec if .cursor does not exist or is not a directory.
#[tauri::command]
fn list_cursor_folder(project_path: String) -> Result<Vec<FileEntry>, String> {
    let base = PathBuf::from(project_path.trim()).join(".cursor");
    if !base.exists() || !base.is_dir() {
        return Ok(vec![]);
    }
    let mut entries = vec![];
    fn collect_files(dir: &Path, out: &mut Vec<FileEntry>) -> Result<(), String> {
        for e in std::fs::read_dir(dir).map_err(|e| e.to_string())? {
            let e = e.map_err(|e| e.to_string())?;
            let path = e.path();
            if path.is_file() {
                let name = path.file_name().and_then(|n| n.to_str()).unwrap_or("").to_string();
                let path_str = path.to_string_lossy().to_string();
                out.push(FileEntry { name, path: path_str });
            } else if path.is_dir() {
                collect_files(&path, out)?;
            }
        }
        Ok(())
    }
    collect_files(&base, &mut entries)?;
    entries.sort_by(|a, b| a.path.cmp(&b.path));
    Ok(entries)
}

/// Read all files under the init template dir (relative to app/project root) and return a map of relative path -> content for Initialize.
#[tauri::command]
fn get_cursor_init_template() -> Result<std::collections::HashMap<String, String>, String> {
    let root = project_root()?;
    let template_dir = root.join(".cursor_template");
    if !template_dir.exists() || !template_dir.is_dir() {
        return Err("Template folder not found".to_string());
    }
    let mut out = std::collections::HashMap::new();
    fn collect(
        dir: &std::path::Path,
        base: &std::path::Path,
        out: &mut std::collections::HashMap<String, String>,
    ) -> Result<(), String> {
        for e in std::fs::read_dir(dir).map_err(|e| e.to_string())? {
            let e = e.map_err(|e| e.to_string())?;
            let path = e.path();
            if path.is_file() {
                let rel = path.strip_prefix(base).map_err(|e| e.to_string())?;
                let rel_str = rel.to_string_lossy().replace('\\', "/");
                let content = std::fs::read_to_string(&path).map_err(|e| e.to_string())?;
                out.insert(rel_str, content);
            } else if path.is_dir() {
                collect(&path, base, out)?;
            }
        }
        Ok(())
    }
    collect(&template_dir, &template_dir, &mut out)?;
    Ok(out)
}

/// Unzip project_template.zip (next to app/project root) into target_path. Strips a single top-level
/// directory (e.g. project_template/) so the template contents land at target_path root.
#[tauri::command]
fn unzip_project_template(target_path: String) -> Result<(), String> {
    let root = project_root()?;
    let zip_path = root.join("project_template.zip");
    if !zip_path.exists() || !zip_path.is_file() {
        return Err("project_template.zip not found next to the app".to_string());
    }
    let target = PathBuf::from(target_path.trim());
    if !target.exists() || !target.is_dir() {
        return Err("Target path does not exist or is not a directory".to_string());
    }

    let file = std::fs::File::open(&zip_path).map_err(|e| e.to_string())?;
    let mut archive = zip::ZipArchive::new(file).map_err(|e| e.to_string())?;

    // Detect single top-level dir: if every entry starts with the same segment (e.g. "project_template/"), strip it.
    let mut prefix: Option<String> = None;
    for i in 0..archive.len() {
        let entry = archive.by_index(i).map_err(|e| e.to_string())?;
        let name = entry.name().replace('\\', "/").trim_end_matches('/').to_string();
        if name.is_empty() || name.contains("..") {
            continue;
        }
        if let Some(first) = name.split('/').next() {
            let seg = format!("{}/", first);
            match &prefix {
                None => prefix = Some(seg),
                Some(p) if p == &seg => {}
                _ => {
                    prefix = None;
                    break;
                }
            }
        }
    }
    // If we have only one top-level segment for all, use it as prefix to strip
    let strip_prefix = prefix.filter(|p| !p.is_empty());

    for i in 0..archive.len() {
        let mut entry = archive.by_index(i).map_err(|e| e.to_string())?;
        let raw_name = entry.name().replace('\\', "/");
        let name = raw_name.trim_end_matches('/');
        if name.is_empty() || name.contains("..") {
            continue;
        }
        let relative = match &strip_prefix {
            Some(p) if name.starts_with(p) => name.strip_prefix(p).unwrap_or(name),
            _ => name,
        };
        let relative = relative.trim_start_matches('/');
        if relative.is_empty() {
            continue;
        }
        let out_path = target.join(relative);
        if entry.is_dir() {
            std::fs::create_dir_all(&out_path).map_err(|e| e.to_string())?;
        } else {
            if let Some(parent) = out_path.parent() {
                std::fs::create_dir_all(parent).map_err(|e| e.to_string())?;
            }
            let mut buf = Vec::new();
            entry.read_to_end(&mut buf).map_err(|e| e.to_string())?;
            std::fs::write(&out_path, &buf).map_err(|e| e.to_string())?;
        }
    }
    Ok(())
}

/// Write a spec file into the project directory (e.g. project_path + "/.cursor/design-x.md").
/// Creates parent directories if needed. relative_path should be like ".cursor/design-abc.md".
#[tauri::command]
fn write_spec_file(project_path: String, relative_path: String, content: String) -> Result<(), String> {
    let base = PathBuf::from(project_path.trim());
    if !base.exists() || !base.is_dir() {
        return Err("Project path does not exist or is not a directory".to_string());
    }
    let full = base.join(relative_path.trim().trim_start_matches('/'));
    if let Some(parent) = full.parent() {
        std::fs::create_dir_all(parent).map_err(|e| e.to_string())?;
    }
    std::fs::write(&full, content).map_err(|e| e.to_string())?;
    Ok(())
}

/// Archive .cursor/7. planner/tickets.md or .cursor/7. planner/features.md to .cursor/legacy/{file}-YYYY-MM-DD.md and create a new empty file.
/// file_kind must be "tickets" or "features".
#[tauri::command]
fn archive_cursor_file(project_path: String, file_kind: String) -> Result<(), String> {
    let base = PathBuf::from(project_path.trim());
    if !base.exists() || !base.is_dir() {
        return Err("Project path does not exist or is not a directory".to_string());
    }
    let (cursor_file, legacy_prefix, minimal_content) = match file_kind.trim() {
        "tickets" => (
            ".cursor/7. planner/tickets.md",
            "tickets",
            "# Work items (tickets) — (project name)\n\n**Project:** (set)\n**Source:** Archived and reset\n**Last updated:** (date)\n\n---\n\n## Summary: Done vs missing\n\n### Done\n\n| Area | What's implemented |\n\n### Missing or incomplete\n\n| Area | Gap |\n\n---\n\n## Prioritized work items (tickets)\n\n### P0 — Critical / foundation\n
#### Feature: (add feature name)\n
- [ ] #1 (add ticket)\n
### P1 — High / quality and maintainability\n
### P2 — Medium / polish and scale\n
### P3 — Lower / later\n
## Next steps\n
1. Add tickets under features.\n",
        ),
        "features" => (
            ".cursor/7. planner/features.md",
            "features",
            "# Features roadmap\n\nFeatures below are derived from .cursor/7. planner/tickets.md. Add features as checklist items with ticket refs, e.g. `- [ ] Feature name — #1, #2`.\n\n## Major features\n\n- [ ] (add feature)\n",
        ),
        _ => return Err("file_kind must be 'tickets' or 'features'".to_string()),
    };
    let cursor_path = base.join(cursor_file);
    let content = if cursor_path.exists() {
        std::fs::read_to_string(&cursor_path).unwrap_or_else(|_| String::new())
    } else {
        String::new()
    };
    let date = chrono::Utc::now().format("%Y-%m-%d").to_string();
    let legacy_name = format!("{}-{}.md", legacy_prefix, date);
    let legacy_path = base.join(".cursor").join("legacy");
    std::fs::create_dir_all(&legacy_path).map_err(|e| e.to_string())?;
    let legacy_full = legacy_path.join(&legacy_name);
    std::fs::write(&legacy_full, content).map_err(|e| e.to_string())?;
    std::fs::write(&cursor_path, minimal_content).map_err(|e| e.to_string())?;
    Ok(())
}

/// List JSON files in data/ directory.

/// Result of analyzing a project directory for AI ticket generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectAnalysis {
    pub name: String,
    pub path: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub package_json: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub readme_snippet: Option<String>,
    pub top_level_dirs: Vec<String>,
    pub top_level_files: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config_snippet: Option<String>,
}

const README_MAX_CHARS: usize = 8000;
const CONFIG_MAX_CHARS: usize = 4000;

/// Analyze a project directory for AI ticket generation: read package.json, README, list top-level structure.
/// Path must be an existing directory (e.g. from all_projects list).
#[tauri::command]
fn analyze_project_for_tickets(project_path: String) -> Result<ProjectAnalysis, String> {
    let path_buf = PathBuf::from(project_path.trim());
    if !path_buf.exists() || !path_buf.is_dir() {
        return Err("Project path does not exist or is not a directory".to_string());
    }
    let name = path_buf
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("project")
        .to_string();
    let path_str = path_buf.to_string_lossy().to_string();

    let package_json = path_buf
        .join("package.json")
        .exists()
        .then(|| std::fs::read_to_string(path_buf.join("package.json")))
        .and_then(Result::ok);

    let readme_snippet = ["README.md", "readme.md", "README.MD"]
        .iter()
        .find(|f| path_buf.join(f).exists())
        .and_then(|f| std::fs::read_to_string(path_buf.join(f)).ok())
        .map(|s| {
            let t = s.trim();
            if t.len() > README_MAX_CHARS {
                format!("{}...", &t[..README_MAX_CHARS])
            } else {
                t.to_string()
            }
        });

    let mut top_level_dirs = Vec::new();
    let mut top_level_files = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&path_buf) {
        for e in entries.flatten() {
            let p = e.path();
            if let Some(n) = p.file_name().and_then(|n| n.to_str()) {
                if n.starts_with('.') && n != ".git" {
                    continue;
                }
                if p.is_dir() {
                    top_level_dirs.push(n.to_string());
                } else {
                    top_level_files.push(n.to_string());
                }
            }
        }
    }
    top_level_dirs.sort();
    top_level_files.sort();

    let config_snippet = ["tsconfig.json", "vite.config.ts", "vite.config.js", "next.config.mjs", "next.config.js", "Cargo.toml", "pyproject.toml", "requirements.txt"]
        .iter()
        .find(|f| path_buf.join(f).exists())
        .and_then(|f| std::fs::read_to_string(path_buf.join(f)).ok())
        .map(|s| {
            let t = s.trim();
            if t.len() > CONFIG_MAX_CHARS {
                format!("{}...", &t[..CONFIG_MAX_CHARS])
            } else {
                t.to_string()
            }
        });

    Ok(ProjectAnalysis {
        name,
        path: path_str,
        package_json,
        readme_snippet,
        top_level_dirs,
        top_level_files,
        config_snippet,
    })
}

fn with_db<F, T>(f: F) -> Result<T, String>
where
    F: FnOnce(&rusqlite::Connection) -> Result<T, String>,
{
    let data = data_root()?;
    let conn = db::open_db(&data.join("app.db"))?;
    seed_initial_data(&conn)?; // New seeding call
    f(&conn)
}

/// Resolve data directory from DB (ADR 069). Uses path stored in kv_store, or fallback from data root, and persists it.
#[tauri::command]
fn resolve_data_dir() -> Result<PathBuf, String> {
    let fallback = data_root()?;
    with_db(|conn| Ok(db::get_data_dir(conn, &fallback)))
}

/// Project record (camelCase for frontend). Stored in kv_store "projects" as JSON array.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Project {
    /// Optional on create; generated if missing or empty.
    #[serde(default)]
    pub id: String,
    /// Default so partial updates (e.g. { runPort }) deserialize without sending name.
    #[serde(default)]
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repo_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub run_port: Option<u16>,
    #[serde(default)]
    pub prompt_ids: Vec<i64>,
    #[serde(default)]
    pub ticket_ids: Vec<String>,
    #[serde(default)]
    pub feature_ids: Vec<String>,
    #[serde(default)]
    pub idea_ids: Vec<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub design_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub architecture_ids: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_categories: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spec_files: Option<Vec<serde_json::Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spec_files_tickets: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spec_files_features: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
}

fn list_projects_impl(conn: &rusqlite::Connection) -> Result<Vec<Project>, String> {
    let json = db::get_projects_json(conn)?;
    let arr: Vec<Project> = serde_json::from_str(&json).unwrap_or_default();
    Ok(arr)
}

#[tauri::command]
fn list_projects() -> Result<Vec<Project>, String> {
    with_db(list_projects_impl)
}

#[tauri::command]
fn get_project(id: String) -> Result<Option<Project>, String> {
    with_db(|conn| {
        let projects = list_projects_impl(conn)?;
        Ok(projects.into_iter().find(|p| p.id == id))
    })
}

#[tauri::command]
fn create_project(project: Project) -> Result<Project, String> {
    // #region agent log
    debug_log("lib.rs:create_project", "create_project command entered", &[("name", project.name.as_str())]);
    // #endregion
    with_db(|conn| {
        let mut projects = list_projects_impl(conn)?;
        let now = now_iso();
        let mut p = project;
        if p.id.is_empty() {
            p.id = uuid::Uuid::new_v4().to_string();
        }
        p.created_at.get_or_insert(now.clone());
        p.updated_at = Some(now);
        projects.push(p.clone());
        let json = serde_json::to_string(&projects).map_err(|e| e.to_string())?;
        db::save_projects_json(conn, &json)?;
        Ok(p)
    })
}

#[tauri::command]
fn update_project(id: String, project: serde_json::Value) -> Result<Project, String> {
    with_db(|conn| {
        let mut projects = list_projects_impl(conn)?;
        let idx = projects.iter().position(|p| p.id == id).ok_or("Project not found")?;
        let now = now_iso();
        let base = projects[idx].clone();
        let updated: Project = serde_json::from_value(project).map_err(|e| e.to_string())?;
        let merged = Project {
            id: base.id,
            name: if updated.name.is_empty() { base.name } else { updated.name },
            description: updated.description.or(base.description),
            repo_path: updated.repo_path.or(base.repo_path),
            run_port: updated.run_port.or(base.run_port),
            prompt_ids: if updated.prompt_ids.is_empty() { base.prompt_ids } else { updated.prompt_ids },
            ticket_ids: if updated.ticket_ids.is_empty() { base.ticket_ids } else { updated.ticket_ids },
            feature_ids: if updated.feature_ids.is_empty() { base.feature_ids } else { updated.feature_ids },
            idea_ids: if updated.idea_ids.is_empty() { base.idea_ids } else { updated.idea_ids },
            design_ids: updated.design_ids.or(base.design_ids),
            architecture_ids: updated.architecture_ids.or(base.architecture_ids),
            entity_categories: updated.entity_categories.or(base.entity_categories),
            spec_files: updated.spec_files.or(base.spec_files),
            spec_files_tickets: updated.spec_files_tickets.or(base.spec_files_tickets),
            spec_files_features: updated.spec_files_features.or(base.spec_files_features),
            created_at: base.created_at,
            updated_at: Some(now),
        };
        projects[idx] = merged.clone();
        let json = serde_json::to_string(&projects).map_err(|e| e.to_string())?;
        db::save_projects_json(conn, &json)?;
        Ok(merged)
    })
}

#[tauri::command]
fn delete_project(id: String) -> Result<(), String> {
    with_db(|conn| {
        let mut projects = list_projects_impl(conn)?;
        let len = projects.len();
        projects.retain(|p| p.id != id);
        if projects.len() == len {
            return Err("Project not found".to_string());
        }
        let json = serde_json::to_string(&projects).map_err(|e| e.to_string())?;
        db::save_projects_json(conn, &json)?;
        Ok(())
    })
}

/// Resolved project: project + linked prompts, tickets, features, ideas (empty), designs, architectures (empty).
#[tauri::command]
fn get_project_resolved(id: String) -> Result<serde_json::Value, String> {
    let project = with_db(|conn| {
        let projects = list_projects_impl(conn)?;
        projects.into_iter().find(|p| p.id == id).ok_or("Project not found".to_string())
    })?;
    let tickets = with_db(db::get_tickets).unwrap_or_default();
    let features = with_db(db::get_features).unwrap_or_default();
    let prompts = with_db(db::get_prompts).unwrap_or_default();
    let designs = with_db(db::get_designs).unwrap_or_default();
    let prompt_ids: Vec<i64> = project.prompt_ids.iter().copied().collect();
    let ticket_ids: Vec<String> = project.ticket_ids.clone();
    let feature_ids: Vec<String> = project.feature_ids.clone();
    let design_ids: Vec<String> = project.design_ids.as_deref().unwrap_or(&[]).to_vec();
    let prompts_resolved: Vec<serde_json::Value> = prompt_ids
        .iter()
        .filter_map(|pid| {
            prompts.iter().find(|p| p.id.parse::<i64>().ok() == Some(*pid)).map(|p| {
                serde_json::json!({
                    "id": p.id.parse::<i64>().unwrap_or(0),
                    "title": p.title,
                    "content": p.content,
                })
            })
        })
        .collect();
    let tickets_resolved: Vec<serde_json::Value> = ticket_ids
        .iter()
        .filter_map(|tid| {
            tickets.iter().find(|t| t.id == *tid).map(|t| {
                serde_json::json!({
                    "id": t.id,
                    "title": t.title,
                    "status": t.status,
                    "description": t.description,
                })
            })
        })
        .collect();
    let features_resolved: Vec<serde_json::Value> = feature_ids
        .iter()
        .filter_map(|fid| {
            features.iter().find(|f| f.id == *fid).map(|f| {
                serde_json::json!({
                    "id": f.id,
                    "title": f.title,
                    "prompt_ids": f.prompt_ids,
                    "project_paths": f.project_paths,
                })
            })
        })
        .collect();
    let designs_resolved: Vec<serde_json::Value> = design_ids
        .iter()
        .filter_map(|did| {
            designs.iter().find(|d| d.id == *did).map(|d| {
                serde_json::json!({ "id": d.id, "name": d.name })
            })
        })
        .collect();
    let ideas_empty: Vec<serde_json::Value> = vec![];
    let architectures_empty: Vec<serde_json::Value> = vec![];
    let resolved = serde_json::json!({
        "id": project.id,
        "name": project.name,
        "description": project.description,
        "repoPath": project.repo_path,
        "runPort": project.run_port,
        "promptIds": project.prompt_ids,
        "ticketIds": project.ticket_ids,
        "featureIds": project.feature_ids,
        "ideaIds": project.idea_ids,
        "designIds": project.design_ids,
        "architectureIds": project.architecture_ids,
        "entityCategories": project.entity_categories,
        "prompts": prompts_resolved,
        "tickets": tickets_resolved,
        "features": features_resolved,
        "ideas": ideas_empty,
        "designs": designs_resolved,
        "architectures": architectures_empty,
    });
    Ok(resolved)
}

#[tauri::command]
fn get_project_export(id: String, category: String) -> Result<String, String> {
    let resolved = get_project_resolved(id)?;
    let value = match category.as_str() {
        "prompts" => resolved.get("prompts"),
        "tickets" => resolved.get("tickets"),
        "features" => resolved.get("features"),
        "ideas" => resolved.get("ideas"),
        "designs" => resolved.get("designs"),
        "architectures" => resolved.get("architectures"),
        "project" => Some(&resolved),
        _ => return Err(format!("Unknown category: {}", category)),
    };
    let out = value
        .map(|v| serde_json::to_string(v).map_err(|e| e.to_string()))
        .unwrap_or_else(|| Ok("[]".to_string()))?;
    Ok(out)
}

#[tauri::command]
fn get_all_projects() -> Result<Vec<String>, String> {
    with_db(db::get_all_projects)
}

/// Collect direct subdirectory paths under `dir` only (one level). Include every entry that is a directory or a symlink (so we don't drop folders or symlinks on macOS).
fn list_subdir_paths(dir: &Path) -> Result<Vec<String>, String> {
    let mut paths = vec![];
    let entries = std::fs::read_dir(dir).map_err(|e| e.to_string())?;
    for entry in entries {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };
        let name = entry.file_name();
        let name_str = name.to_string_lossy();
        if name_str == "." || name_str == ".." {
            continue;
        }
        if name_str.starts_with('.') {
            continue;
        }
        let full = dir.join(&name);
        let is_symlink = entry.file_type().map(|ft| ft.is_symlink()).unwrap_or(false);
        let is_dir = full.is_dir();
        if !is_dir && !is_symlink {
            continue;
        }
        let path_str = full.to_string_lossy().to_string();
        paths.push(path_str);
    }
    Ok(paths)
}

/// One entry in the debug listing: why it was included or skipped.
#[derive(serde::Serialize)]
struct FebruaryFolderDebugEntry {
    name: String,
    included: bool,
    is_dir: bool,
    is_symlink: bool,
    file_type_err: Option<String>,
}

/// Parse FEBRUARY_DIR= value from a line of .env content.
fn parse_february_dir_line(line: &str) -> Option<PathBuf> {
    let line = line.trim();
    if !line.starts_with("FEBRUARY_DIR=") {
        return None;
    }
    let value = line["FEBRUARY_DIR=".len()..].trim().trim_matches('"').trim_matches('\'');
    if value.is_empty() {
        return None;
    }
    let pb = PathBuf::from(value);
    if pb.is_absolute() {
        Some(pb)
    } else {
        None
    }
}

/// Read all lines from path_file; return path as PathBuf if absolute and existing dir.
fn read_february_dirs_from_file(path_file: &Path) -> Vec<PathBuf> {
    let content = match std::fs::read_to_string(path_file) {
        Ok(c) => c,
        Err(_) => return vec![],
    };
    let mut out = vec![];
    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() {
            continue;
        }
        let pb = PathBuf::from(line);
        if pb.is_absolute() && pb.is_dir() {
            out.push(pb);
        }
    }
    out
}

/// Read all projects root paths from data/february-dir.txt (one path per line). Check project data dir, cwd/data, then walk up from exe.
fn february_dirs_from_data_file() -> Vec<PathBuf> {
    if let Ok(ws) = project_root() {
        let data = data_dir(&ws);
        let path_file = data.join("february-dir.txt");
        if path_file.exists() {
            let dirs = read_february_dirs_from_file(&path_file);
            if !dirs.is_empty() {
                return dirs;
            }
        }
    }
    if let Ok(cwd) = std::env::current_dir() {
        let path_file = cwd.join("data").join("february-dir.txt");
        if path_file.exists() {
            let dirs = read_february_dirs_from_file(&path_file);
            if !dirs.is_empty() {
                return dirs;
            }
        }
    }
    if let Ok(exe) = std::env::current_exe() {
        let mut dir = exe.parent().map(PathBuf::from).unwrap_or_default();
        for _ in 0..15 {
            if dir.as_os_str().is_empty() {
                break;
            }
            let path_file = dir.join("data").join("february-dir.txt");
            if path_file.exists() {
                let dirs = read_february_dirs_from_file(&path_file);
                if !dirs.is_empty() {
                    return dirs;
                }
            }
            if let Some(p) = dir.parent() {
                dir = p.to_path_buf();
            } else {
                break;
            }
        }
    }
    // 4) Bundled app: use app data dir so user can add february-dir.txt there
    if let Ok(data_dir) = app_data_data_dir() {
        let path_file = data_dir.join("february-dir.txt");
        if path_file.exists() {
            let dirs = read_february_dirs_from_file(&path_file);
            if !dirs.is_empty() {
                return dirs;
            }
        }
    }
    vec![]
}

/// Parse FEBRUARY_DIR= value from a line; may contain multiple paths separated by ; or ,.
fn parse_february_dir_line_multi(line: &str) -> Vec<PathBuf> {
    let line = line.trim();
    if !line.starts_with("FEBRUARY_DIR=") {
        return vec![];
    }
    let value = line["FEBRUARY_DIR=".len()..].trim().trim_matches('"').trim_matches('\'');
    let mut out = vec![];
    for part in value.split(&[';', ','][..]) {
        let part = part.trim();
        if part.is_empty() {
            continue;
        }
        let pb = PathBuf::from(part);
        if pb.is_absolute() {
            out.push(pb);
        }
    }
    out
}

/// All configured projects roots: data/february-dir.txt (all lines) + FEBRUARY_DIR (split by ; or ,).
fn resolve_february_dirs() -> Vec<PathBuf> {
    let mut candidates: Vec<PathBuf> = february_dirs_from_data_file();
    if !candidates.is_empty() {
        return candidates;
    }
    if let Ok(val) = std::env::var("FEBRUARY_DIR") {
        for part in val.split(&[';', ','][..]) {
            let part = part.trim();
            if part.is_empty() {
                continue;
            }
            let pb = PathBuf::from(part);
            if pb.is_absolute() {
                candidates.push(pb);
            }
        }
    }
    if !candidates.is_empty() {
        return candidates;
    }
    let try_env_file = |path: &Path| -> Vec<PathBuf> {
        let content = match std::fs::read_to_string(path) {
            Ok(c) => c,
            Err(_) => return vec![],
        };
        for line in content.lines() {
            let parsed = parse_february_dir_line_multi(line);
            if !parsed.is_empty() {
                return parsed;
            }
            if let Some(pb) = parse_february_dir_line(line) {
                return vec![pb];
            }
        }
        vec![]
    };
    if let Ok(ws) = project_root() {
        let dirs = try_env_file(&ws.join(".env"));
        if !dirs.is_empty() {
            return dirs;
        }
    }
    if let Ok(cwd) = std::env::current_dir() {
        let dirs = try_env_file(&cwd.join(".env"));
        if !dirs.is_empty() {
            return dirs;
        }
    }
    if let Ok(exe) = std::env::current_exe() {
        let mut dir = exe.parent().map(PathBuf::from).unwrap_or_default();
        for _ in 0..15 {
            if dir.as_os_str().is_empty() {
                break;
            }
            let dirs = try_env_file(&dir.join(".env"));
            if !dirs.is_empty() {
                return dirs;
            }
            if let Some(p) = dir.parent() {
                dir = p.to_path_buf();
            } else {
                break;
            }
        }
    }
    vec![]
}

/// Debug: list every read_dir entry with included/is_dir/is_symlink so we can see why a folder is skipped.
fn list_subdir_paths_debug(dir: &Path) -> Result<Vec<FebruaryFolderDebugEntry>, String> {
    let mut out = vec![];
    let entries = std::fs::read_dir(dir).map_err(|e| e.to_string())?;
    for entry in entries {
        let (name_str, is_dir, is_symlink, file_type_err) = match &entry {
            Ok(e) => {
                let name = e.file_name();
                let name_str = name.to_string_lossy().to_string();
                if name_str == "." || name_str == ".." || name_str.starts_with('.') {
                    continue;
                }
                let full = dir.join(&name);
                let ft = e.file_type();
                let (is_symlink, file_type_err) = match &ft {
                    Ok(ft) => (ft.is_symlink(), None),
                    Err(e) => (false, Some(e.to_string())),
                };
                let is_dir = full.is_dir();
                (name_str, is_dir, is_symlink, file_type_err)
            }
            Err(e) => {
                out.push(FebruaryFolderDebugEntry {
                    name: format!("<error: {}>", e),
                    included: false,
                    is_dir: false,
                    is_symlink: false,
                    file_type_err: Some(e.to_string()),
                });
                continue;
            }
        };
        let included = is_dir || is_symlink;
        out.push(FebruaryFolderDebugEntry {
            name: name_str,
            included,
            is_dir,
            is_symlink,
            file_type_err,
        });
    }
    Ok(out)
}

/// Debug: return raw folder names from the first configured root (to verify what the backend sees).
#[tauri::command]
fn list_february_folders_debug() -> Result<serde_json::Value, String> {
    let mut candidates: Vec<PathBuf> = resolve_february_dirs()
        .into_iter()
        .filter(|pb| pb.is_dir())
        .collect();
    if candidates.is_empty() {
        if let Ok(ws) = project_root() {
            if let Some(parent) = ws.parent() {
                let parent_buf = parent.to_path_buf();
                if parent_buf.is_dir() {
                    candidates.push(parent_buf);
                }
            }
        }
    }
    let root = candidates.first().cloned().unwrap_or_else(PathBuf::new);
    let root_str = root.to_string_lossy().to_string();
    let names: Vec<String> = list_subdir_paths(&root)
        .unwrap_or_default()
        .into_iter()
        .filter_map(|p| PathBuf::from(&p).file_name().map(|n| n.to_string_lossy().to_string()))
        .collect();
    let out = serde_json::json!({
        "root": root_str,
        "count": names.len(),
        "names": names
    });
    Ok(out)
}

/// Debug: return every read_dir entry with included/is_dir/is_symlink/file_type_err so we can see why a folder is skipped.
#[tauri::command]
fn list_february_folders_debug_entries() -> Result<serde_json::Value, String> {
    let mut candidates: Vec<PathBuf> = resolve_february_dirs()
        .into_iter()
        .filter(|pb| pb.is_dir())
        .collect();
    if candidates.is_empty() {
        if let Ok(ws) = project_root() {
            if let Some(parent) = ws.parent() {
                let parent_buf = parent.to_path_buf();
                if parent_buf.is_dir() {
                    candidates.push(parent_buf);
                }
            }
        }
    }
    let root = candidates.first().cloned().unwrap_or_else(PathBuf::new);
    let root_str = root.to_string_lossy().to_string();
    let entries = list_subdir_paths_debug(&root).unwrap_or_default();
    let skipped: Vec<&FebruaryFolderDebugEntry> = entries.iter().filter(|e| !e.included).collect();
    let out = serde_json::json!({
        "root": root_str,
        "total_entries": entries.len(),
        "included_count": entries.iter().filter(|e| e.included).count(),
        "skipped": skipped.iter().map(|e| serde_json::json!({
            "name": e.name,
            "is_dir": e.is_dir,
            "is_symlink": e.is_symlink,
            "file_type_err": e.file_type_err
        })).collect::<Vec<_>>(),
        "entries": entries.iter().map(|e| serde_json::json!({
            "name": e.name,
            "included": e.included,
            "is_dir": e.is_dir,
            "is_symlink": e.is_symlink,
            "file_type_err": e.file_type_err
        })).collect::<Vec<_>>()
    });
    Ok(out)
}

/// List all subdirectories of the configured projects root(s). Used by Projects page Local repos card.
/// No filter by name—every folder is included. Paths from data/february-dir.txt (one per line) or FEBRUARY_DIR (; or , separated); else parent of project root.
#[tauri::command]
fn list_february_folders() -> Result<Vec<String>, String> {
    let mut candidates: Vec<PathBuf> = resolve_february_dirs()
        .into_iter()
        .filter(|pb| pb.is_dir())
        .collect();
    let mut seen = HashSet::new();
    candidates.retain(|pb| seen.insert(pb.clone()));

    if candidates.is_empty() {
        if let Ok(ws) = project_root() {
            if let Some(parent) = ws.parent() {
                let parent_buf = parent.to_path_buf();
                let canonical_parent = parent_buf.canonicalize().ok().unwrap_or(parent_buf);
                if canonical_parent.is_dir() {
                    candidates.push(canonical_parent);
                }
            }
        }
    }

    let mut seen = HashSet::new();
    let mut paths = vec![];
    for dir in &candidates {
        if let Ok(subdirs) = list_subdir_paths(dir) {
            for s in subdirs {
                if seen.insert(s.clone()) {
                    paths.push(s);
                }
            }
        }
    }
    paths.sort();
    Ok(paths)
}

#[tauri::command]
fn get_active_projects() -> Result<Vec<String>, String> {
    with_db(db::get_active_projects)
}

#[tauri::command]
fn get_prompts() -> Result<Vec<Prompt>, String> {
    with_db(db::get_prompts)
}

#[tauri::command]
fn save_prompts(prompts: Vec<Prompt>) -> Result<(), String> {
    with_db(|conn| db::save_prompts(conn, &prompts))
}

#[tauri::command]
fn add_prompt(title: String, content: String) -> Result<Prompt, String> {
    let mut prompts = with_db(db::get_prompts).map_err(|e| e.to_string())?;
    let next_id: i64 = prompts
        .iter()
        .filter_map(|p| p.id.parse().ok())
        .max()
        .map(|n: i64| n + 1)
        .unwrap_or(1);
    let now = now_iso();
    let new_prompt = Prompt {
        id: next_id.to_string(),
        title: title.trim().to_string(),
        content,
        created_at: now.clone(),
        updated_at: now,
    };
    prompts.push(new_prompt.clone());
    with_db(|conn| db::save_prompts(conn, &prompts))?;
    Ok(new_prompt)
}

#[tauri::command]
fn get_designs() -> Result<Vec<Design>, String> {
    with_db(db::get_designs)
}

#[tauri::command]
fn save_designs(designs: Vec<Design>) -> Result<(), String> {
    with_db(|conn| db::save_designs(conn, &designs))
}

#[tauri::command]
fn save_active_projects(projects: Vec<String>) -> Result<(), String> {
    with_db(|conn| db::save_active_projects(conn, &projects))
}

#[tauri::command]
fn get_tickets() -> Result<Vec<Ticket>, String> {
    with_db(db::get_tickets)
}

#[tauri::command]
fn save_tickets(tickets: Vec<Ticket>) -> Result<(), String> {
    with_db(|conn| db::save_tickets(conn, &tickets))
}

#[tauri::command]
fn get_features() -> Result<Vec<Feature>, String> {
    with_db(db::get_features)
}

#[tauri::command]
fn save_features(features: Vec<Feature>) -> Result<(), String> {
    with_db(|conn| db::save_features(conn, &features))
}

#[tauri::command]
fn get_kv_store_entries() -> Result<Vec<db::KvEntry>, String> {
    with_db(db::get_kv_store_entries)
}

/// Return the data directory path (from DB, ADR 069). Used by UI to show where data is stored.
#[tauri::command]
fn get_data_dir() -> Result<String, String> {
    resolve_data_dir().map(|p| p.to_string_lossy().to_string())
}

/// Path to february-dir.txt (one path per line = project roots). In dev: repo data dir; when bundled: app data dir so the built app can find config.
#[tauri::command]
fn get_february_dir_config_path() -> Result<String, String> {
    data_root().map(|d| d.join("february-dir.txt").to_string_lossy().to_string())
}

/// Aggregated counts for the dashboard metrics view.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DashboardMetrics {
    pub tickets_count: u32,
    pub features_count: u32,
    pub prompts_count: u32,
    pub designs_count: u32,
    pub active_projects_count: u32,
    pub all_projects_count: u32,
}

#[tauri::command]
fn get_dashboard_metrics() -> Result<DashboardMetrics, String> {
    with_db(|conn| {
        let tickets = db::get_tickets(conn)?;
        let features = db::get_features(conn)?;
        let prompts = db::get_prompts(conn)?;
        let designs = db::get_designs(conn)?;
        let active = db::get_active_projects(conn)?;
        let all = db::get_all_projects(conn)?;
        Ok(DashboardMetrics {
            tickets_count: tickets.len() as u32,
            features_count: features.len() as u32,
            prompts_count: prompts.len() as u32,
            designs_count: designs.len() as u32,
            active_projects_count: active.len() as u32,
            all_projects_count: all.len() as u32,
        })
    })
}

fn run_script_inner(
    app: AppHandle,
    state: State<'_, RunningState>,
    ws: PathBuf,
    run_id: String,
    run_label: String,
    prompt_ids: Vec<u32>,
    combined_prompt: Option<String>,
    active_projects: Vec<String>,
    timing: TimingParams,
) -> Result<(), String> {
    let run_label_clone = run_label.clone();
    let script = script_path(&ws);
    let prompt_ids_str: Vec<String> = prompt_ids.iter().map(|n| n.to_string()).collect();

    let data = resolve_data_dir()?;
    let projects_file: PathBuf = if active_projects.is_empty() {
        data.join("cursor_projects.json")
    } else {
        let tmp = std::env::temp_dir().join(format!("run_prompts_{}.json", run_id));
        let content =
            serde_json::to_string_pretty(&active_projects).map_err(|e| e.to_string())?;
        std::fs::write(&tmp, content).map_err(|e| e.to_string())?;
        tmp
    };

    let prompt_file_path: Option<PathBuf> = match combined_prompt {
        Some(content) => {
            let tmp = std::env::temp_dir().join(format!("run_combined_prompt_{}.txt", run_id));
            std::fs::write(&tmp, content).map_err(|e| e.to_string())?;
            Some(tmp)
        }
        None => None,
    };

    let mut cmd = Command::new("bash");
    cmd.arg(script.as_os_str());
    if let Some(ref path) = prompt_file_path {
        cmd.arg("-F").arg(path.as_os_str());
    } else {
        cmd.arg("-p").args(&prompt_ids_str);
    }
    cmd.arg(projects_file.as_os_str())
        .current_dir(&ws)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    #[cfg(unix)]
    cmd.process_group(0);
    cmd.env("SLEEP_AFTER_OPEN_PROJECT", timing.sleep_after_open_project.to_string())
        .env("SLEEP_AFTER_WINDOW_FOCUS", timing.sleep_after_window_focus.to_string())
        .env("SLEEP_BETWEEN_SHIFT_TABS", timing.sleep_between_shift_tabs.to_string())
        .env("SLEEP_AFTER_ALL_SHIFT_TABS", timing.sleep_after_all_shift_tabs.to_string())
        .env("SLEEP_AFTER_CMD_N", timing.sleep_after_cmd_n.to_string())
        .env("SLEEP_BEFORE_PASTE", timing.sleep_before_paste.to_string())
        .env("SLEEP_AFTER_PASTE", timing.sleep_after_paste.to_string())
        .env("SLEEP_AFTER_ENTER", timing.sleep_after_enter.to_string())
        .env("SLEEP_BETWEEN_PROJECTS", timing.sleep_between_projects.to_string())
        .env("SLEEP_BETWEEN_ROUNDS", timing.sleep_between_rounds.to_string());

    let mut child = cmd.spawn().map_err(|e| e.to_string())?;
    let stdout = child.stdout.take().ok_or("no stdout")?;
    let stderr = child.stderr.take().ok_or("no stderr")?;

    {
        let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
        guard.insert(
            run_id.clone(),
            RunEntry {
                child,
                label: run_label.clone(),
            },
        );
    }

    let app_stdout = app.clone();
    let app_stderr = app.clone();
    let app_exited = app.clone();
    let runs_handle = Arc::clone(&state.runs);
    let run_id_stdout = run_id.clone();
    let run_id_stderr = run_id.clone();
    let run_id_exited = run_id.clone();
    thread::spawn(move || {
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stdout.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stdout.clone(),
                        line,
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        let reader = BufReader::new(stderr);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stderr.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stderr.clone(),
                        line: format!("[stderr] {}", line),
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        loop {
            let exit_code_to_emit: Option<Option<i32>> = {
                let mut guard = match runs_handle.lock() {
                    Ok(g) => g,
                    Err(_) => break,
                };
                if let Some(entry) = guard.get_mut(&run_id_exited) {
                    if let Some(status) = entry.child.try_wait().ok().flatten() {
                        let code = status.code();
                        guard.remove(&run_id_exited);
                        Some(code)
                    } else {
                        None
                    }
                } else {
                    break;
                }
            };
            if let Some(exit_code) = exit_code_to_emit {
                let _ = app_exited.emit(
                    "script-exited",
                    ScriptExitedPayload {
                        run_id: run_id_exited,
                        label: run_label_clone.clone(),
                        exit_code,
                    },
                );
                break;
            }
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    Ok(())
}

fn run_analysis_script_inner(
    app: AppHandle,
    state: State<'_, RunningState>,
    ws: PathBuf,
    run_id: String,
    run_label: String,
    project_path: String,
) -> Result<(), String> {
    let run_label_clone = run_label.clone();
    let script = analysis_script_path(&ws);
    if !script.exists() {
        return Err(format!(
            "Analysis script not found: {}",
            script.to_string_lossy()
        ));
    }
    let mut cmd = Command::new("bash");
    cmd.arg(script.as_os_str())
        .arg("-P")
        .arg(project_path.as_str())
        .current_dir(&ws)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    #[cfg(unix)]
    cmd.process_group(0);

    let mut child = cmd.spawn().map_err(|e| e.to_string())?;
    let stdout = child.stdout.take().ok_or("no stdout")?;
    let stderr = child.stderr.take().ok_or("no stderr")?;

    {
        let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
        guard.insert(
            run_id.clone(),
            RunEntry {
                child,
                label: run_label.clone(),
            },
        );
    }

    let app_stdout = app.clone();
    let app_stderr = app.clone();
    let app_exited = app.clone();
    let runs_handle = Arc::clone(&state.runs);
    let run_id_stdout = run_id.clone();
    let run_id_stderr = run_id.clone();
    let run_id_exited = run_id.clone();
    thread::spawn(move || {
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stdout.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stdout.clone(),
                        line,
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        let reader = BufReader::new(stderr);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stderr.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stderr.clone(),
                        line: format!("[stderr] {}", line),
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        loop {
            let exit_code_to_emit: Option<Option<i32>> = {
                let mut guard = match runs_handle.lock() {
                    Ok(g) => g,
                    Err(_) => break,
                };
                if let Some(entry) = guard.get_mut(&run_id_exited) {
                    if let Some(status) = entry.child.try_wait().ok().flatten() {
                        let code = status.code();
                        guard.remove(&run_id_exited);
                        Some(code)
                    } else {
                        None
                    }
                } else {
                    break;
                }
            };
            if let Some(exit_code) = exit_code_to_emit {
                let _ = app_exited.emit(
                    "script-exited",
                    ScriptExitedPayload {
                        run_id: run_id_exited,
                        label: run_label_clone.clone(),
                        exit_code,
                    },
                );
                break;
            }
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    Ok(())
}

fn run_implement_all_script_inner(
    app: AppHandle,
    state: State<'_, RunningState>,
    ws: PathBuf,
    run_id: String,
    run_label: String,
    project_path: String,
    slot: Option<u8>,
    prompt_content: Option<String>,
) -> Result<(), String> {
    let run_label_clone = run_label.clone();
    let script = implement_all_script_path(&ws);
    if !script.exists() {
        return Err(format!(
            "Implement All script not found: {}",
            script.to_string_lossy()
        ));
    }
    let prompt_path: Option<PathBuf> = match &prompt_content {
        Some(content) => {
            let p = std::env::temp_dir().join(format!("kw_implement_all_prompt_{}.txt", run_id));
            std::fs::write(&p, content).map_err(|e| e.to_string())?;
            Some(p)
        }
        None => None,
    };
    let mut cmd = Command::new("bash");
    cmd.arg(script.as_os_str())
        .arg("-P")
        .arg(project_path.as_str());
    if let Some(s) = slot {
        if (1..=3).contains(&s) {
            cmd.arg("-S").arg(s.to_string());
        }
    }
    if let Some(ref path) = prompt_path {
        cmd.arg("-F").arg(path.as_os_str());
    }
    cmd.current_dir(&ws)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    #[cfg(unix)]
    cmd.process_group(0);

    let mut child = cmd.spawn().map_err(|e| e.to_string())?;
    let stdout = child.stdout.take().ok_or("no stdout")?;
    let stderr = child.stderr.take().ok_or("no stderr")?;

    {
        let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
        guard.insert(
            run_id.clone(),
            RunEntry {
                child,
                label: run_label.clone(),
            },
        );
    }

    let app_stdout = app.clone();
    let app_stderr = app.clone();
    let app_exited = app.clone();
    let runs_handle = Arc::clone(&state.runs);
    let run_id_stdout = run_id.clone();
    let run_id_stderr = run_id.clone();
    let run_id_exited = run_id.clone();
    thread::spawn(move || {
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stdout.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stdout.clone(),
                        line,
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        let reader = BufReader::new(stderr);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stderr.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stderr.clone(),
                        line: format!("[stderr] {}", line),
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        loop {
            let exit_code_to_emit: Option<Option<i32>> = {
                let mut guard = match runs_handle.lock() {
                    Ok(g) => g,
                    Err(_) => break,
                };
                if let Some(entry) = guard.get_mut(&run_id_exited) {
                    if let Some(status) = entry.child.try_wait().ok().flatten() {
                        let code = status.code();
                        guard.remove(&run_id_exited);
                        Some(code)
                    } else {
                        None
                    }
                } else {
                    break;
                }
            };
            if let Some(exit_code) = exit_code_to_emit {
                let _ = app_exited.emit(
                    "script-exited",
                    ScriptExitedPayload {
                        run_id: run_id_exited,
                        label: run_label_clone.clone(),
                        exit_code,
                    },
                );
                break;
            }
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    Ok(())
}

/// Single-prompt terminal agent run (debug "Run terminal agent to fix", Setup prompt, temp ticket, etc.).
/// Uses script/run_terminal_agent.sh (from repo ws or from app bundle resources). Not used for Implement All.
fn run_run_terminal_agent_script_inner(
    app: AppHandle,
    state: State<'_, RunningState>,
    script_path: PathBuf,
    current_dir: PathBuf,
    run_id: String,
    run_label: String,
    project_path: String,
    prompt_content: String,
) -> Result<(), String> {
    let run_label_clone = run_label.clone();
    if !script_path.exists() {
        return Err(format!(
            "Run terminal agent script not found: {}",
            script_path.to_string_lossy()
        ));
    }
    let p = std::env::temp_dir().join(format!("kw_run_terminal_agent_prompt_{}.txt", run_id));
    std::fs::write(&p, &prompt_content).map_err(|e| e.to_string())?;
    let mut cmd = Command::new("bash");
    cmd.arg(script_path.as_os_str())
        .arg("-P")
        .arg(project_path.as_str())
        .arg("-F")
        .arg(p.as_os_str())
        .current_dir(&current_dir)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    // GUI apps (e.g. launched from Desktop) get a minimal PATH; extend so `agent` and other CLIs are found
    if let Ok(home) = std::env::var("HOME") {
        let extra = format!("{}/.local/bin:/usr/local/bin", home);
        let path = std::env::var_os("PATH").unwrap_or_default();
        let new_path = if path.is_empty() {
            extra
        } else {
            format!("{}:{}", extra, path.to_string_lossy())
        };
        cmd.env("PATH", new_path);
    }
    #[cfg(unix)]
    cmd.process_group(0);

    let mut child = cmd.spawn().map_err(|e| e.to_string())?;
    let stdout = child.stdout.take().ok_or("no stdout")?;
    let stderr = child.stderr.take().ok_or("no stderr")?;

    {
        let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
        guard.insert(
            run_id.clone(),
            RunEntry {
                child,
                label: run_label.clone(),
            },
        );
    }

    let app_stdout = app.clone();
    let app_stderr = app.clone();
    let app_exited = app.clone();
    let runs_handle = Arc::clone(&state.runs);
    let run_id_stdout = run_id.clone();
    let run_id_stderr = run_id.clone();
    let run_id_exited = run_id.clone();
    thread::spawn(move || {
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stdout.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stdout.clone(),
                        line,
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        let reader = BufReader::new(stderr);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stderr.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stderr.clone(),
                        line: format!("[stderr] {}", line),
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        loop {
            let exit_code_to_emit: Option<Option<i32>> = {
                let mut guard = match runs_handle.lock() {
                    Ok(g) => g,
                    Err(_) => break,
                };
                if let Some(entry) = guard.get_mut(&run_id_exited) {
                    if let Some(status) = entry.child.try_wait().ok().flatten() {
                        let code = status.code();
                        guard.remove(&run_id_exited);
                        Some(code)
                    } else {
                        None
                    }
                } else {
                    break;
                }
            };
            if let Some(exit_code) = exit_code_to_emit {
                let _ = app_exited.emit(
                    "script-exited",
                    ScriptExitedPayload {
                        run_id: run_id_exited,
                        label: run_label_clone.clone(),
                        exit_code,
                    },
                );
                break;
            }
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    Ok(())
}

/// Opens 3 Terminal.app windows (macOS only), each running `cd project_path && agent`.
/// Gives you a real TTY so Cursor CLI runs in interactive mode instead of "print mode".
#[tauri::command]
async fn open_implement_all_in_system_terminal(project_path: String) -> Result<(), String> {
    #[cfg(not(target_os = "macos"))]
    {
        let _ = project_path;
        return Err("Open in system terminal is only supported on macOS.".to_string());
    }
    #[cfg(target_os = "macos")]
    {
        // Escape path for shell: single-quote wrap, inner ' → '\''
        let path_escaped = project_path.replace('\'', "'\\''");
        let shell_cmd = format!("cd '{}' && agent", path_escaped);
        // Escape for AppleScript string: \ → \\, " → \"
        let as_escaped = shell_cmd.replace('\\', "\\\\").replace('"', "\\\"");
        let script = format!(
            "tell application \"Terminal\" to do script \"{}\"",
            as_escaped
        );
        for _ in 0..3 {
            Command::new("osascript")
                .arg("-e")
                .arg(&script)
                .spawn()
                .map_err(|e| format!("Failed to open Terminal: {}", e))?;
        }
        Ok(())
    }
}

/// Opens Terminal.app (macOS) and runs `npm run <script_name>` in the project directory.
#[tauri::command]
async fn run_npm_script_in_external_terminal(project_path: String, script_name: String) -> Result<(), String> {
    #[cfg(not(target_os = "macos"))]
    {
        let _ = (project_path, script_name);
        return Err("External terminal is only supported on macOS.".to_string());
    }
    #[cfg(target_os = "macos")]
    {
        if script_name.is_empty()
            || !script_name
                .chars()
                .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == ':')
        {
            return Err("Invalid script name: only letters, numbers, hyphen, underscore and colon allowed".to_string());
        }
        let dir = Path::new(&project_path)
            .canonicalize()
            .map_err(|e| format!("Project path invalid: {}", e))?;
        if !dir.is_dir() {
            return Err("Project path is not a directory".to_string());
        }
        let path_str = dir.to_string_lossy();
        let path_escaped = path_str.replace('\'', "'\\''");
        let shell_cmd = format!("cd '{}' && npm run {}", path_escaped, script_name);
        let as_escaped = shell_cmd.replace('\\', "\\\\").replace('"', "\\\"");
        let script = format!(
            "tell application \"Terminal\" to do script \"{}\"",
            as_escaped
        );
        Command::new("osascript")
            .arg("-e")
            .arg(&script)
            .spawn()
            .map_err(|e| format!("Failed to open Terminal: {}", e))?;
        Ok(())
    }
}

/// Opens Terminal.app (macOS) and runs `npm run build:desktop` in the current working directory.
/// Use when running the app via `tauri dev` so the cwd is the project root.
#[tauri::command]
fn run_build_desktop() -> Result<(), String> {
    #[cfg(not(target_os = "macos"))]
    {
        return Err("Rebuild on desktop is only supported on macOS.".to_string());
    }
    #[cfg(target_os = "macos")]
    {
        let dir = std::env::current_dir().map_err(|e| format!("Could not get current directory: {}", e))?;
        let path_str = dir.to_string_lossy();
        let path_escaped = path_str.replace('\'', "'\\''");
        let shell_cmd = format!("cd '{}' && npm run build:desktop", path_escaped);
        let as_escaped = shell_cmd.replace('\\', "\\\\").replace('"', "\\\"");
        let script = format!(
            "tell application \"Terminal\" to do script \"{}\"",
            as_escaped
        );
        Command::new("osascript")
            .arg("-e")
            .arg(&script)
            .spawn()
            .map_err(|e| format!("Failed to open Terminal: {}", e))?;
        Ok(())
    }
}

/// Opens one system terminal (Terminal.app on macOS) with the project path as the current working directory.
/// On non-macOS returns an error; same as open_implement_all_in_system_terminal and run_npm_script_in_external_terminal.
#[tauri::command]
fn open_project_in_system_terminal(project_path: String) -> Result<(), String> {
    #[cfg(not(target_os = "macos"))]
    {
        let _ = project_path;
        return Err("Open in terminal is only supported on macOS.".to_string());
    }
    #[cfg(target_os = "macos")]
    {
        let dir = Path::new(project_path.trim())
            .canonicalize()
            .map_err(|e| format!("Project path invalid: {}", e))?;
        if !dir.is_dir() {
            return Err("Project path is not a directory".to_string());
        }
        let path_str = dir.to_string_lossy();
        let path_escaped = path_str.replace('\'', "'\\''");
        let shell_cmd = format!("cd '{}'", path_escaped);
        let as_escaped = shell_cmd.replace('\\', "\\\\").replace('"', "\\\"");
        let script = format!(
            "tell application \"Terminal\" to do script \"{}\"",
            as_escaped
        );
        Command::new("osascript")
            .arg("-e")
            .arg(&script)
            .spawn()
            .map_err(|e| format!("Failed to open Terminal: {}", e))?;
        Ok(())
    }
}

/// Opens a project directory in Cursor or Visual Studio Code.
/// `editor` must be "cursor" or "vscode". On macOS uses `open -a "Cursor" path` / `open -a "Visual Studio Code" path`;
/// on Windows/Linux spawns the editor CLI with the path (cursor/code in PATH when installed).
#[tauri::command]
fn open_project_in_editor(project_path: String, editor: String) -> Result<(), String> {
    let path = project_path.trim();
    if path.is_empty() {
        return Err("Project path is empty".to_string());
    }
    let dir = Path::new(path)
        .canonicalize()
        .map_err(|e| format!("Invalid project path: {}", e))?;
    if !dir.is_dir() {
        return Err("Project path is not a directory".to_string());
    }
    let path_str = dir.to_string_lossy();
    let editor_lower = editor.trim().to_lowercase();

    #[cfg(target_os = "macos")]
    {
        let (app_name, label) = match editor_lower.as_str() {
            "cursor" => ("Cursor", "Cursor"),
            "vscode" | "code" => ("Visual Studio Code", "VS Code"),
            _ => return Err(format!("Unknown editor '{}'. Use 'cursor' or 'vscode'.", editor.trim())),
        };
        Command::new("open")
            .arg("-a")
            .arg(app_name)
            .arg(path_str.as_ref())
            .spawn()
            .map_err(|e| format!("Failed to open in {}: {}", label, e))?;
        Ok(())
    }

    #[cfg(not(target_os = "macos"))]
    {
        let (bin, label) = match editor_lower.as_str() {
            "cursor" => ("cursor", "Cursor"),
            "vscode" | "code" => ("code", "VS Code"),
            _ => return Err(format!("Unknown editor '{}'. Use 'cursor' or 'vscode'.", editor.trim())),
        };
        Command::new(bin)
            .arg(path_str.as_ref())
            .spawn()
            .map_err(|e| format!("Failed to open in {}: {}. Is {} installed and in PATH?", label, e, label))?;
        Ok(())
    }
}

/// Opens the given directory in the system file manager (Finder on macOS, Explorer on Windows, xdg-open on Linux).
/// Caller must ensure `dir` exists and is a directory.
fn open_dir_in_file_manager(dir: &Path) -> Result<(), String> {
    let path_str = dir.to_string_lossy();

    #[cfg(target_os = "macos")]
    {
        Command::new("open")
            .arg(path_str.as_ref())
            .spawn()
            .map_err(|e| format!("Failed to open in Finder: {}", e))?;
    }

    #[cfg(target_os = "windows")]
    {
        let path_win = path_str.replace('/', "\\");
        Command::new("explorer")
            .arg(&path_win)
            .spawn()
            .map_err(|e| format!("Failed to open in Explorer: {}", e))?;
    }

    #[cfg(not(any(target_os = "macos", target_os = "windows")))]
    {
        Command::new("xdg-open")
            .arg(path_str.as_ref())
            .spawn()
            .map_err(|e| format!("Failed to open in file manager: {}", e))?;
    }

    Ok(())
}

/// Opens the given path in the system file manager (Finder on macOS, Explorer on Windows, xdg-open on Linux).
#[tauri::command]
fn open_path_in_file_manager(path: String) -> Result<(), String> {
    let path = path.trim();
    if path.is_empty() {
        return Err("Path is empty".to_string());
    }
    let dir = Path::new(path)
        .canonicalize()
        .map_err(|e| format!("Invalid path: {}", e))?;
    if !dir.is_dir() {
        return Err("Path is not a directory".to_string());
    }
    open_dir_in_file_manager(&dir)
}

/// Opens the app repo's .cursor/documentation folder (or .cursor if documentation subfolder is missing) in the system file manager.
#[tauri::command]
fn open_documentation_folder() -> Result<(), String> {
    let root = project_root()?;
    let doc_dir = root.join(".cursor").join("documentation");
    let cursor_dir = root.join(".cursor");
    let to_open = if doc_dir.is_dir() {
        doc_dir
    } else if cursor_dir.is_dir() {
        cursor_dir
    } else {
        return Err("Documentation folder (.cursor/documentation or .cursor) not found.".to_string());
    };
    open_dir_in_file_manager(&to_open)
}

/// Returns the app repo's .cursor/documentation folder path (or .cursor if documentation subfolder is missing). Used for copy-to-clipboard (ADR 0215).
#[tauri::command]
fn get_documentation_folder_path() -> Result<String, String> {
    let root = project_root()?;
    let doc_dir = root.join(".cursor").join("documentation");
    let cursor_dir = root.join(".cursor");
    let to_open = if doc_dir.is_dir() {
        doc_dir
    } else if cursor_dir.is_dir() {
        cursor_dir
    } else {
        return Err("Documentation folder (.cursor/documentation or .cursor) not found.".to_string());
    };
    Ok(to_open.to_string_lossy().to_string())
}

/// Opens the app repo's .cursor/technologies folder (or .cursor if technologies subfolder is missing) in the system file manager.
#[tauri::command]
fn open_technologies_folder() -> Result<(), String> {
    let root = project_root()?;
    let tech_dir = root.join(".cursor").join("technologies");
    let cursor_dir = root.join(".cursor");
    let to_open = if tech_dir.is_dir() {
        tech_dir
    } else if cursor_dir.is_dir() {
        cursor_dir
    } else {
        return Err("Technologies folder (.cursor/technologies or .cursor) not found.".to_string());
    };
    open_dir_in_file_manager(&to_open)
}

/// Returns the app repo's .cursor/technologies folder path (or .cursor if technologies subfolder is missing). Used for copy-to-clipboard (ADR 0216).
#[tauri::command]
fn get_technologies_folder_path() -> Result<String, String> {
    let root = project_root()?;
    let tech_dir = root.join(".cursor").join("technologies");
    let cursor_dir = root.join(".cursor");
    let path = if tech_dir.is_dir() {
        tech_dir
    } else if cursor_dir.is_dir() {
        cursor_dir
    } else {
        return Err("Technologies folder (.cursor/technologies or .cursor) not found.".to_string());
    };
    Ok(path.to_string_lossy().to_string())
}

/// Opens the app repo's .cursor/0. ideas folder (or .cursor if that subfolder is missing) in the system file manager.
#[tauri::command]
fn open_ideas_folder() -> Result<(), String> {
    let root = project_root()?;
    let ideas_dir = root.join(".cursor").join("0. ideas");
    let cursor_dir = root.join(".cursor");
    let to_open = if ideas_dir.is_dir() {
        ideas_dir
    } else if cursor_dir.is_dir() {
        cursor_dir
    } else {
        return Err("Ideas folder (.cursor/0. ideas or .cursor) not found.".to_string());
    };
    open_dir_in_file_manager(&to_open)
}

/// Returns the path to the ideas folder (.cursor/0. ideas or .cursor) for clipboard copy (ADR 0219).
#[tauri::command]
fn get_ideas_folder_path() -> Result<String, String> {
    let root = project_root()?;
    let ideas_dir = root.join(".cursor").join("0. ideas");
    let cursor_dir = root.join(".cursor");
    let path = if ideas_dir.is_dir() {
        ideas_dir
    } else if cursor_dir.is_dir() {
        cursor_dir
    } else {
        return Err("Ideas folder (.cursor/0. ideas or .cursor) not found.".to_string());
    };
    Ok(path.to_string_lossy().to_string())
}

#[tauri::command]
async fn run_implement_all(
    app: AppHandle,
    state: State<'_, RunningState>,
    project_path: String,
    slot: Option<u8>,
    prompt_content: Option<String>,
) -> Result<RunIdResponse, String> {
    let ws = project_root()?;
    let run_id = gen_run_id();
    let label = match slot {
        Some(1) => "Implement All (Terminal 1)".to_string(),
        Some(2) => "Implement All (Terminal 2)".to_string(),
        Some(3) => "Implement All (Terminal 3)".to_string(),
        _ => "Implement All".to_string(),
    };
    run_implement_all_script_inner(app, state, ws, run_id.clone(), label, project_path, slot, prompt_content)?;
    Ok(RunIdResponse { run_id })
}

/// Args for run_run_terminal_agent; accept camelCase from frontend (projectPath, promptContent, label).
#[derive(serde::Deserialize)]
struct RunTerminalAgentArgs {
    #[serde(alias = "projectPath")]
    project_path: String,
    #[serde(alias = "promptContent")]
    prompt_content: String,
    label: String,
}

#[tauri::command]
async fn run_run_terminal_agent(
    app: AppHandle,
    state: State<'_, RunningState>,
    args: RunTerminalAgentArgs,
) -> Result<RunIdResponse, String> {
    let RunTerminalAgentArgs {
        project_path,
        prompt_content,
        label,
    } = args;
    let run_id = gen_run_id();
    let run_label = if label.trim().is_empty() {
        "Terminal agent".to_string()
    } else {
        label.trim().to_string()
    };
    let (script_path, current_dir) = match project_root() {
        Ok(ws) => (run_terminal_agent_script_path(&ws), ws),
        Err(_) => {
            let resource = app
                .path()
                .resolve("run_terminal_agent.sh", BaseDirectory::Resource)
                .map_err(|e| format!("Worker script not found in app bundle: {}", e))?;
            let dir = resource
                .parent()
                .map(|p| p.to_path_buf())
                .unwrap_or_else(std::env::temp_dir);
            (resource, dir)
        }
    };
    run_run_terminal_agent_script_inner(
        app,
        state,
        script_path,
        current_dir,
        run_id.clone(),
        run_label,
        project_path,
        prompt_content,
    )?;
    Ok(RunIdResponse { run_id })
}

#[tauri::command]
async fn run_analysis_script(
    app: AppHandle,
    state: State<'_, RunningState>,
    project_path: String,
) -> Result<RunIdResponse, String> {
    let ws = project_root()?;
    let run_id = gen_run_id();
    let label = format!("Analysis: {}", Path::new(&project_path).file_name().and_then(|n| n.to_str()).unwrap_or("project"));
    run_analysis_script_inner(app, state, ws, run_id.clone(), label, project_path)?;
    Ok(RunIdResponse { run_id })
}

fn run_npm_script_inner(
    app: AppHandle,
    state: State<'_, RunningState>,
    run_id: String,
    run_label: String,
    project_path: String,
    script_name: String,
) -> Result<(), String> {
    // Allow only safe script names (alphanumeric, hyphen, underscore, colon for e.g. dev:full)
    if script_name.is_empty()
        || !script_name
            .chars()
            .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == ':')
    {
        return Err("Invalid script name: only letters, numbers, hyphen, underscore and colon allowed".to_string());
    }
    let dir = Path::new(&project_path)
        .canonicalize()
        .map_err(|e| format!("Project path invalid: {}", e))?;
    if !dir.is_dir() {
        return Err("Project path is not a directory".to_string());
    }

    let run_label_clone = run_label.clone();
    let mut cmd = Command::new("npm");
    cmd.arg("run")
        .arg(script_name.as_str())
        .current_dir(&dir)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    #[cfg(unix)]
    cmd.process_group(0);

    let mut child = cmd.spawn().map_err(|e| e.to_string())?;
    let stdout = child.stdout.take().ok_or("no stdout")?;
    let stderr = child.stderr.take().ok_or("no stderr")?;

    {
        let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
        guard.insert(
            run_id.clone(),
            RunEntry {
                child,
                label: run_label.clone(),
            },
        );
    }

    let app_stdout = app.clone();
    let app_stderr = app.clone();
    let app_exited = app.clone();
    let runs_handle = Arc::clone(&state.runs);
    let run_id_stdout = run_id.clone();
    let run_id_stderr = run_id.clone();
    let run_id_exited = run_id.clone();
    thread::spawn(move || {
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stdout.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stdout.clone(),
                        line,
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        let reader = BufReader::new(stderr);
        for line in reader.lines() {
            if let Ok(line) = line {
                let _ = app_stderr.emit(
                    "script-log",
                    ScriptLogPayload {
                        run_id: run_id_stderr.clone(),
                        line: format!("[stderr] {}", line),
                    },
                );
            }
        }
    });
    thread::spawn(move || {
        loop {
            let exit_code_to_emit: Option<Option<i32>> = {
                let mut guard = match runs_handle.lock() {
                    Ok(g) => g,
                    Err(_) => break,
                };
                if let Some(entry) = guard.get_mut(&run_id_exited) {
                    if let Some(status) = entry.child.try_wait().ok().flatten() {
                        let code = status.code();
                        guard.remove(&run_id_exited);
                        Some(code)
                    } else {
                        None
                    }
                } else {
                    break;
                }
            };
            if let Some(exit_code) = exit_code_to_emit {
                let _ = app_exited.emit(
                    "script-exited",
                    ScriptExitedPayload {
                        run_id: run_id_exited,
                        label: run_label_clone.clone(),
                        exit_code,
                    },
                );
                break;
            }
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    Ok(())
}

#[tauri::command]
async fn run_npm_script(
    app: AppHandle,
    state: State<'_, RunningState>,
    project_path: String,
    script_name: String,
) -> Result<RunIdResponse, String> {
    let run_id = gen_run_id();
    let label = format!("npm run {}", script_name);
    run_npm_script_inner(app, state, run_id.clone(), label, project_path, script_name)?;
    Ok(RunIdResponse { run_id })
}

#[tauri::command]
async fn run_script(
    app: AppHandle,
    state: State<'_, RunningState>,
    args: RunScriptArgs,
) -> Result<RunIdResponse, String> {
    let ws = project_root()?;
    if args.run_label.is_none() {
        save_active_projects(args.active_projects.clone())?;
    }
    let run_id = gen_run_id();
    let label = args
        .run_label
        .unwrap_or_else(|| "Manual run".to_string());
    run_script_inner(
        app,
        state,
        ws,
        run_id.clone(),
        label,
        args.prompt_ids,
        args.combined_prompt,
        args.active_projects,
        args.timing,
    )?;
    Ok(RunIdResponse { run_id })
}

#[tauri::command]
fn list_running_runs(state: State<'_, RunningState>) -> Result<Vec<RunningRunInfo>, String> {
    let guard = state.runs.lock().map_err(|e| e.to_string())?;
    Ok(guard
        .iter()
        .map(|(run_id, entry)| RunningRunInfo {
            run_id: run_id.clone(),
            label: entry.label.clone(),
        })
        .collect())
}

#[tauri::command]
fn stop_run(state: State<'_, RunningState>, run_id: String) -> Result<(), String> {
    let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
    if let Some(mut entry) = guard.remove(&run_id) {
        let pid = entry.child.id() as i32;
        #[cfg(unix)]
        {
            let _ = unsafe { libc::kill(-pid, libc::SIGKILL) };
        }
        let _ = entry.child.kill();
    }
    Ok(())
}

#[tauri::command]
fn stop_script(state: State<'_, RunningState>) -> Result<(), String> {
    let mut guard = state.runs.lock().map_err(|e| e.to_string())?;
    for (_run_id, mut entry) in guard.drain() {
        let pid = entry.child.id() as i32;
        #[cfg(unix)]
        {
            let _ = unsafe { libc::kill(-pid, libc::SIGKILL) };
        }
        let _ = entry.child.kill();
    }
    Ok(())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_dialog::init())
        .manage(RunningState::default())
        .setup(|app| {
            // Workaround for macOS/Tauri bug: WebView often shows white instead of devUrl.
            // 1) Load a local loader HTML first (shows "kwcode" then redirects to dev server).
            // 2) Retry navigating to app URL at 2s, 4s, 6s in case loader redirect fails.
            #[cfg(debug_assertions)]
            {
                let app_url = "http://127.0.0.1:4000/".to_string();
                let app_handle = app.handle().clone();

                // Write loader to temp file so we can navigate to it (file:// works when devUrl fails).
                let loader_url = (|| -> Option<Url> {
                    let html = include_str!("../../public/tauri-load.html");
                    let temp = std::env::temp_dir().join("tauri-load.html");
                    std::fs::write(&temp, html).ok()?;
                    let path = temp.canonicalize().ok()?;
                    Url::from_file_path(path).ok()
                })();

                std::thread::spawn(move || {
                    // First: try to show loader (file://) so user sees something instead of white.
                    if let Some(ref url) = loader_url {
                        std::thread::sleep(std::time::Duration::from_millis(150));
                        let handle = app_handle.clone();
                        let load_url = url.clone();
                        let _ = app_handle.run_on_main_thread(move || {
                            for (_, w) in handle.webview_windows() {
                                let _ = w.navigate(load_url.as_str().parse().unwrap_or_else(|_| "http://127.0.0.1:4000/".parse().unwrap()));
                                break;
                            }
                        });
                    }

                    // Fallback: force-navigate to dev server in case loader or initial load failed.
                    for _ in 0..3 {
                        std::thread::sleep(std::time::Duration::from_millis(2000));
                        let handle = app_handle.clone();
                        let url = app_url.clone();
                        let _ = app_handle.run_on_main_thread(move || {
                            for (_, w) in handle.webview_windows() {
                                let _ = w.navigate(
                                    url.parse().unwrap_or_else(|_| "http://127.0.0.1:4000/".parse().unwrap()),
                                );
                                let js = format!("window.location.href = {}", serde_json::to_string(&url).unwrap_or_else(|_| "\"http://127.0.0.1:4000/\"".into()));
                                let _ = w.eval(&js);
                                break;
                            }
                        });
                    }
                });
            }
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            read_file_as_base64,
            read_file_text,
            read_file_text_under_root,
            list_files_under_root,
            list_scripts,
            list_cursor_folder,
            get_cursor_init_template,
            unzip_project_template,
            write_spec_file,
            archive_cursor_file,
            get_git_info,
            get_git_head,
            get_git_diff_name_status,
            get_implementation_log_entries,
            get_project_tickets,
            get_project_kanban_state,
            get_project_milestones,
            create_plan_ticket,
            set_plan_kanban_state,
            update_plan_ticket,
            delete_plan_ticket,
            get_ideas_list,
            update_implementation_log_entry_status,
            append_implementation_log_entry,
            get_git_file_view,
            git_fetch,
            git_pull,
            git_push,
            git_commit,
            analyze_project_for_tickets,
            get_all_projects,
            list_projects,
            get_project,
            create_project,
            update_project,
            delete_project,
            get_project_resolved,
            get_project_export,
            list_february_folders,
            list_february_folders_debug,
            list_february_folders_debug_entries,
            get_active_projects,
            get_prompts,
            save_prompts,
            add_prompt,
            get_designs,
            save_designs,
            save_active_projects,
            get_tickets,
            save_tickets,
            get_features,
            save_features,
            run_script,
            run_analysis_script,
            run_npm_script,
            run_npm_script_in_external_terminal,
            run_build_desktop,
            run_implement_all,
            run_run_terminal_agent,
            open_implement_all_in_system_terminal,
            open_project_in_system_terminal,
            open_project_in_editor,
            open_path_in_file_manager,
            open_documentation_folder,
            get_documentation_folder_path,
            open_technologies_folder,
            get_technologies_folder_path,
            open_ideas_folder,
            get_ideas_folder_path,
            list_running_runs,
            stop_run,
            stop_script,
            get_kv_store_entries,
            get_data_dir,
            get_february_dir_config_path,
            get_dashboard_metrics,
            frontend_debug_log,
            get_app_version,
            navigate_webview_to
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}