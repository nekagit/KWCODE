[
  {
    "id": "de9af8c1-f246-48d4-a753-a6db7fce74ed",
    "name": "Clean Architecture (template)",
    "category": "clean",
    "description": "Clean Architecture separates concerns into layers: Domain (entities, use cases), Application (application logic), Infrastructure (frameworks, DB, external APIs), and Presentation (UI). Dependencies point inward; inner layers know nothing of outer layers.",
    "practices": "- **Dependency rule**: Source code dependencies point only inward (toward higher-level policies).\n- **Entities**: Enterprise business rules; no dependencies on frameworks or UI.\n- **Use cases**: Application-specific business rules; orchestrate data flow.\n- **Interface adapters**: Convert data between use cases and external systems (e.g. presenters, gateways).\n- **Frameworks & drivers**: DB, UI, web; only the outermost layer.\n- **Testability**: Core logic testable without UI, DB, or external services.",
    "scenarios": "- Medium to large applications with clear domain logic.\n- When you need to swap UI or persistence without changing business rules.\n- When multiple UIs (web, CLI, API) share the same core.\n- When team wants clear boundaries and testability.",
    "references": "Robert C. Martin, Clean Architecture (book).",
    "anti_patterns": "Putting business logic in controllers or DB layer; letting outer layers leak into domain.",
    "examples": "Domain layer: entities + use case interfaces. Infrastructure: implementations of repositories and external APIs. Presentation: controllers that call use cases.",
    "created_at": "2026-02-05T23:49:19.986Z",
    "updated_at": "2026-02-05T23:49:19.986Z"
  },
  {
    "id": "37395600-0cd5-4f90-ae3c-bcee9ddde6fe",
    "name": "Clean Architecture",
    "category": "clean",
    "description": "Utilizes a layered approach to separate concerns and enhance maintainability.",
    "practices": "Follow SOLID principles and ensure separation of concerns.",
    "scenarios": "Applicable for scalable web applications with evolving requirements.",
    "created_at": "2026-02-05T23:53:57.395Z",
    "updated_at": "2026-02-05T23:53:57.395Z"
  },
  {
    "id": "1c984ee9-78c0-4070-b104-b389116e99c7",
    "name": "Clean Architecture (template)",
    "category": "clean",
    "description": "Clean Architecture separates concerns into layers: Domain (entities, use cases), Application (application logic), Infrastructure (frameworks, DB, external APIs), and Presentation (UI). Dependencies point inward; inner layers know nothing of outer layers.",
    "practices": "- **Dependency rule**: Source code dependencies point only inward (toward higher-level policies).\n- **Entities**: Enterprise business rules; no dependencies on frameworks or UI.\n- **Use cases**: Application-specific business rules; orchestrate data flow.\n- **Interface adapters**: Convert data between use cases and external systems (e.g. presenters, gateways).\n- **Frameworks & drivers**: DB, UI, web; only the outermost layer.\n- **Testability**: Core logic testable without UI, DB, or external services.",
    "scenarios": "- Medium to large applications with clear domain logic.\n- When you need to swap UI or persistence without changing business rules.\n- When multiple UIs (web, CLI, API) share the same core.\n- When team wants clear boundaries and testability.",
    "references": "Robert C. Martin, Clean Architecture (book).",
    "anti_patterns": "Putting business logic in controllers or DB layer; letting outer layers leak into domain.",
    "examples": "Domain layer: entities + use case interfaces. Infrastructure: implementations of repositories and external APIs. Presentation: controllers that call use cases.",
    "created_at": "2026-02-06T00:09:52.252Z",
    "updated_at": "2026-02-06T00:09:52.252Z"
  }
]